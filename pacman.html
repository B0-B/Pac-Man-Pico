<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>
        (async() => {

            // graphics input
            const   height = 400,
                    width = 600,
                    delay = 0,
                    timestep = 35,
                    mazeWallGaps = 5,
                    resolution = 20,
                    wallColor = '#1b0f9d',
                    retroBg = '#121212';

            // general
            function u(){return Math.random()}
            function fl(x){return Math.floor(x)}
            function sl(t){return new Promise(r=>setTimeout(r,t))}

            // format body
            const body = document.body;
            body.style.margin = 0;
            body.style.overflow = 'hidden';

            // create canvas
            const   canvas = document.createElement('canvas');
            const   ctx = canvas.getContext('2d');
            const   ctxc = ctx.canvas;
            const   r = resolution;
            const   columns = fl(width/r),
                    rows = fl(height/r);
                    
            // format canvas and add to body
            ctxc.width = width;
            ctxc.height = height;
            ctx.fillStyle = retroBg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            canvas.style.width = columns*r;
            canvas.style.height = rows*r;
            canvas.style.zIndex = '1';
            body.prepend(canvas);

            // build grid
            async function grid (columns, rows, resolution=5) {
                let     mat = [];
                const   c = resolution;
                for (let i=0; i<rows; i++) {
                    row = [];
                    for (let j=0; j<columns; j++) {
                        row.push({x:j*c,y:i*c,v:0})
                    } mat.push(row)
                } return mat;
            }
            const _grid = await grid(columns, rows, r);

            // create maze
            // -- helper methods start --
            async function block (col, row, res, grid_obj, ctx, color, value=1) {
                ctx.fillStyle = color;
                ctx.fillRect(col*res, row*res, res, res);
                grid_obj[row][col].v = value;
                if (delay) {
                    await sl(delay)
                }
            }
            function blockFromCoord (coord) {
                return _grid[fl(coord.y/r)][fl(coord.x/r)]
            }
            function coordIsFree (x,y) {
                return !blockFromCoord ({x:x,y:y}).v
            }
            function free (col, row, grid) {
                if (grid[row][col].v) {return false}
                return true
            }
            function space (x_old, y_old, x_new, y_new, grid, radius=1) {
                if (!free(x_new, y_new, grid)){return false}
                for (let i of [-radius,0,radius]) {
                    for (let j of [-radius, 0, radius]) {
                        if (i==0 && j==0){continue}
                        if (y_new+i==y_old || x_new+j==x_old){continue} 
                        if (grid[y_new+i][x_new+j].v) {
                            return false
                        }
                    }
                }
                return true
            }
            
            var door, cage;

            // -- helper methods end --
            async function maze (grid_obj, ctx, color, snakes=100, length=100, gaps=2) {
                
                const   g = grid_obj;
                const   res = g[0][1].x - g[0][0].x,
                        col = g[0].length,
                        row = g.length;

                ctx.fillStyle = color;
                
                // create outter frame
                for (let i=0; i<rows; i++) {
                    await block(0, i, res, g, ctx, color);
                    await block(col-1, i, res, g, ctx, color)
                }
                for (let i=0; i<col; i++) {
                    await block(i, 0, res, g, ctx, color);
                    await block(i, row-1, res, g, ctx, color)
                }

                // place the cage
                dim = [];
                for (ind of [0,1]) {
                    d = [col, row][ind]
                    if (d%2==0){
                        dim[ind] = 4
                    } else {
                        dim[ind] = 3
                    }
                }
                start = [(col-dim[0])/2, (row-dim[1])/2];
                await block(start[0], start[1], res, g, ctx, color)
                for (let x = 0; x < dim[0]+1; x++) {
                    await block(start[0]+x, start[1], res, g, ctx, color);
                    await block(start[0]+x, start[1]+dim[1], res, g, ctx, color);
                    
                } for (let y = 0; y < dim[1]; y++) {
                    await block(start[0], start[1]+y, res, g, ctx, color);
                    await block(start[0]+dim[0], start[1]+y, res, g, ctx, color);
                }
                cage = [[start[0],start[0]+dim[0]],[start[1],start[1]+dim[1]]];

                // cut out cage door
                door = {col: fl(start[0]+dim[0]/2), row: fl(start[1])} 
                await block(door.col, door.row, res, g, ctx, retroBg);
                ctx.fillStyle = '#fff';
                ctx.fillRect(door.col*res, door.row*res+.4*res, res, .2*res);
                //await close_door(door);

                // fill internal space with snake method
                let p = {x:2,y:2},
                    br = 0;
                for (let i = 0; i < snakes; i++) {

                    // find new position, if search takes to long it ran out of space, then return
                    const lim = row*col*100;
                    for (let z = 0; z < lim; z++) {
                        [x,y] = [fl(u()*col), fl(u()*row)]
                        if (space(x,y,x,y,g) && !in_cage(x*r,y*r)) {p.x=x;p.y=y;break}
                        if (z == lim-1){br=1;break}
                    }
                    if(br){break}



                    // fill starting point
                    block(p.x, p.y, res, g, ctx, color)
                    
                    v = '';
                    count = 0;
                    for (let i=0; i<length; i++) {

                        // check directions
                        d=[];
                        for (let c of [[p.x-1, p.y,'l'],[p.x+1, p.y,'r'],[p.x, p.y+1,'u'],[p.x, p.y-1,'d']]) {
                            if (space(p.x, p.y, c[0], c[1], g)) {d.push(c[2])}
                        }

                        // throw a die with geom. decreasing probability to keep the same direction
                        if (!(d.includes(v) && u() < 1/(1+count))) {
                            v = d[fl(u()*d.length)]
                            count = 0
                        }

                        // adjust position
                        if (v == 'l') {p.x--}
                        else if (v == 'r') {p.x++}
                        else if (v == 'u') {p.y++}
                        else if (v == 'd') {p.y--}
                        else {break}

                        await block(p.x, p.y, res, g, ctx, color)
                        count++
                    }
                }

                // cut out some gaps
                success = 0
                while (success < gaps) {
                    [x,y] = [2+fl(u()*(col-4)),2+fl(u()*(row-4))];
                    outside_cage = (x < start[0] || x > start[0]+dim[0]) || (y < start[1] || y > start[1]+dim[1])
                    if (outside_cage && !free(x,y,g) && ((!free(x+1,y,g) && !free(x-1,y,g) && free(x,y+1,g) && free(x,y-1,g)) || (free(x+1,y,g) && free(x-1,y,g) && !free(x,y+1,g) && !free(x,y-1,g)))) {
                        await block(x, y, res, g, ctx, retroBg, 0);
                        success++
                    }
                }
            }
            async function open_door (timeout, door) {
                await block(door.col, door.row, r, _grid, ctx, retroBg,0);
                ctx.fillStyle = '#383';
                ctx.fillRect(door.col*r, door.row*r+.4*r, r, .2*r);
                await sl(timeout);
                await block(door.col, door.row, r, _grid, ctx, retroBg,1);
                ctx.fillStyle = '#fff';
                ctx.fillRect(door.col*r, door.row*r+.4*r, r, .2*r);
            }
            async function close_door (door) {
                await open_door(0, door)
            }
            function in_cage (x, y) {
                
                _c = fl(x/r);
                _r = fl(y/r);

                if ( _c > cage[0][0] && _c < cage[0][1] && _r > cage[1][0] && _r < cage[1][1] ) {
                    return true
                } 
                
                return false

            }

            // initialize maze
            maze(_grid, ctx, wallColor, snakes=30, length=100, gaps=mazeWallGaps);

            /*  Active frame */
            const   canvas_active = document.createElement('canvas');   
            const   ctxa = canvas_active.getContext('2d');
            canvas_active.style.width = columns*r;
            canvas_active.style.height = rows*r;
            ctxa.canvas.width = width;
            ctxa.canvas.height = height;
            canvas_active.style.position = 'absolute';
            canvas_active.style.top = '0';
            canvas_active.style.left = '0';
            canvas_active.style.zIndex = '2';
            body.prepend(canvas_active)

            /* pacman data */
            let pac_v = '',
                pac_p = {x:0,y:0},
                pac_s = 0,
                pac_mouth_states = [.2,.5,.8,.9,.8,.5], 
                pac_direction_phase = {'r': 0, 'u':Math.PI/2, 'l': Math.PI, 'd': 1.5*Math.PI};
                increment = 4,
                tol = .45 * r;
            async function draw_pacman (coord, mouth_state, direction_phase, resolution, ctx) {
                
                const rad = fl(resolution/2);
                const c = [coord.x+rad, coord.y+rad];

                ctx.beginPath();
                ctx.arc(c[0], c[1], rad, mouth_state, 2*Math.PI-mouth_state);
                ctx.fillStyle = ctx.strokeStyle = '#d9e312';
                ctx.lineTo(c[0],c[1]);
                ctx.lineTo(c[0]+rad*Math.cos(mouth_state),c[1]+rad*Math.sin(mouth_state));
                ctx.closePath();
                ctx.fill();
                ctx.save()
                ctx.rotate(direction_phase)
                ctx.restore();

            }
            async function clear_pac () {
                ctxa.clearRect(pac_p.x-.2*r,pac_p.y-.2*r,1.4*r,1.4*r);
            }
            function set_pac (coord) {
                pac_p = coord
            }
            async function move_pac (direction) {
                if (direction== 'r') {
                    pac_p.x += increment
                } else if (direction == 'l') {
                    pac_p.x -= increment
                } else if (direction == 'u') {
                    pac_p.y -= increment
                } else if (direction == 'd') {
                    pac_p.y += increment
                }
                pac_s = (pac_s+1)%pac_mouth_states.length;
            }
            async function can_move_in_dir (direction, x, y, inc, tol) {
                [x,y] = [x+r/2,y+r/2]; // center
                if (    (direction == 'r' && coordIsFree(x + tol + inc, y+tol) && coordIsFree(x + tol + inc, y-tol)) || 
                        (direction == 'l' && coordIsFree(x - tol - inc, y+tol) && coordIsFree(x - tol - inc, y-tol)) ||
                        (direction == 'u' && coordIsFree(x + tol, y - tol - inc) && coordIsFree(x - tol, y - tol - inc)) ||
                        (direction == 'd' && coordIsFree(x + tol, y + tol + inc) && coordIsFree(x - tol, y + tol + inc)) ) {
                            return true
                        }
                return false
            }
            

            // bind keys to pacman
            document.addEventListener('keydown', (event) => {
                var name = event.key,
                    code = event.code,
                    d;
                if (name == 'w' || name == 'ArrowUp') {d = 'u'} 
                else if (name == 'a' || name == 'ArrowLeft') {d = 'l'} 
                else if (name == 's' || name == 'ArrowDown') {d = 'd'} 
                else if (name == 'd' || name == 'ArrowRight') {d = 'r'}
                pac_v = d
            }, false);


            /* Ghosts data */
            // https://en.wikipedia.org/wiki/Ghosts_(Pac-Man)
            var ghost_increment = 2;
            const d_x = fl(_grid[0].length/2), d_y = fl(_grid.length/2);
            const spawn = _grid[d_y][d_x];
            const tol_g = .45 * r;
            const backwards = {'l':'r','r':'l','u':'d','d':'u'}
            const randomness = 0.2; // how likely to take a turn on a crossing except the origin direction
            var chase = true;
            var walking_dist = 10;
            var ghosts_active = true;
            async function draw_ghost (coord, direction, color, resolution, ctx) {
                const   rad = fl(resolution/2);
                const c = [coord.x+rad, coord.y+rad];
                ctx.beginPath();
                ctx.arc(c[0], c[1], rad, -Math.PI, 0);
                ctx.fillStyle = ctx.strokeStyle = color;
                ctx.fillRect(coord.x, coord.y+rad, resolution, fl(rad/2));
                for ([dx,dy] of [[2,2],[1.75,1.75],[1.5,2],[1.25,1.75],[1,2],[.75,1.75],[.5,2],[.25,1.75],[0,2],[0,1.75]]) {
                    ctx.lineTo(coord.x+dx*rad, coord.y+dy*rad);
                }
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                for (s of [-1,1]) {
                    ctx.arc(c[0]+s*fl(rad/2.3), c[1]-fl(rad/3.5), fl(rad/3), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();    
                }
                ctx.closePath();
                
                // eyes
                ctx.fillStyle = retroBg;
                ctx.beginPath();
                if (direction == 'u') {
                    bias = [0,-.2]
                } else if (direction == 'd') {
                    bias = [0,.2]
                } else if (direction == 'l') {
                    bias = [-.2,0]
                } else if (direction == 'r') {
                    bias = [.2,0]
                } else {
                    bias = [0,0]
                }
                ctx.arc(c[0]+fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.arc(c[0]-fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.fill();
                ctx.closePath();
            }
            function increment_in_dir (x,y,d,i) {
                if (d == 'r') {
                    x += i
                } else if (d == 'l') {
                    x -= i
                } else if (d == 'u') {
                    y -= i
                } else if (d == 'd') {
                    y += i
                } return [x,y]
            }
            function sample_new_dir (g, d_old, pd) {
                pd.splice(pd.indexOf(d_old),1);
                g.s = 0;
                return pd[fl(u()*pd.length)];
            }
            function dist_to_pac (x, y) {
                return (x-pac_p.x)**2+(y-pac_p.y)**2
            }
            async function move_ghost (ghost) {

                /* agent algorithm */

                const g = ghost;

                var direction;

                // determine possible directions
                pd = []; 
                for (d of ['l','r','u','d']) {
                    if (await can_move_in_dir(d, g.x, g.y, ghost_increment, tol_g)) {
                        pd.push(d)
                    }
                }

                // determine backward direction
                const backDir = backwards[g.v];

                // pick direction if there is only one option
                if (pd.length < 2 ) {direction = pd[0]}

                // acc. to provided randomness, sample a random move sometimes
                if (pd.length > 2 && u() < randomness) {
                    direction = sample_new_dir(g, backDir, pd);
                }

                // determine direction with longest distance
                target_dir = ''
                if (!direction) {
                    ghost_increment = 2
                    length = 0, l=0; inc = r/2-1;
                    for (d of pd) {
                        let [pos_x, pos_y] = [g.x, g.y];
                        
                        while (true) {
                            [pos_x,pos_y]=increment_in_dir(pos_x,pos_y,d,inc);
                            
                            if (coordIsFree(pos_x, pos_y)) {
                                l++
                            } else {
                                if (l>length) {
                                    length = l;
                                    target_dir = d;
                                } 
                                l = 0;
                                break
                            }
                        }
                    }
                }

                // case dependent direction and move parameters
                if (in_cage(g.x, g.y)) {

                    walking_dist = 20
                    ghost_increment = 2

                    if (!direction) {
                        
                        // sample new direction
                        if (!(u()<1/(1+s/walking_dist)) || g.v=='') {
                            direction = sample_new_dir(g, backDir, pd);
                        }

                    }
                    
                } 

                // tries to minimize distance to pac
                else if (chase) {

                    ghost_increment =  4
                    walking_dist = 300;

                    if (u() < 0.1) {
                        dist = 1e10;
                        if (!direction) {
                            for(let d of pd) {
                                [pos_x, pos_y] = increment_in_dir(g.x,g.y,d,inc);
                                console.log(pos_x, pos_y)
                                dtp = dist_to_pac(pos_x, pos_y);
                                if (dtp < dist) {
                                    dist = dtp;
                                    direction = d
                                }
                            }
                        }
                    }
                    

                }

                // random movement
                else {

                    walking_dist = 200
                    ghost_increment = 2
                    
                    if (!direction) {

                        // sample new direction after a walking distance (on avg.)
                        if (!(u()<1/(1+s/walking_dist)) || g.v=='') {
                            
                            // apply new direction
                            direction = target_dir;
                            g.s=0;

                        } 
                    }

                }

                // update direction
                if (direction) {
                    g.v = direction;
                }
                
                
                // check if the target coordinate is free, then apply direction
                let [x,y] = [g.x,g.y];
                [x,y] = increment_in_dir(x,y,g.v,ghost_increment);
                
                if (coordIsFree(x,y)) {
                    g.x = x;
                    g.y = y;
                } else {
                    // if backwards is the longest path always pick it
                    if (target_dir == backDir) {
                        g.v = backDir
                    } 
                    // otherwise sample a new non-backward path
                    else {
                        g.v = sample_new_dir(g, backDir, pd)
                    }
                    
                }

                // increment step count
                g.s++

            }
            
            // render all objects on active canvas 
            set_pac(_grid[1][1]);
            draw_pacman(pac_p, pac_mouth_states[pac_s], pac_direction_phase[pac_v], r, ctxa);
            const ghosts = [
            {x:spawn.x+r,y:spawn.y+r,c:'red',v:'',s:0},
            {x:spawn.x+r,y:spawn.y+r,c:'cyan',v:'',s:0},
            {x:spawn.x+r,y:spawn.y+r,c:'orange',v:'',s:0},
            {x:spawn.x+r,y:spawn.y+r,c:'pink',v:'',s:0}];
            for (g of ghosts) {
                draw_ghost(g, g.v, g.c, r, ctxa);
            }
            
            
            // define main engine for rendering dynamics on active canvas
            async function engine () {
                
                while (true) {

                    // update pacman
                    if (pac_v != '' && await can_move_in_dir(pac_v, pac_p.x, pac_p.y, increment, tol)) {move_pac(pac_v)} 
                    draw_pacman(pac_p, pac_mouth_states[pac_s], pac_direction_phase[pac_v], r, ctxa);

                    //update ghosts
                    for (const g of ghosts) {

                        await move_ghost(g);
                        draw_ghost(g, g.v, g.c, r, ctxa);

                    }

                    // delay
                    await sl(timestep)

                    // clear screen
                    ctxa.clearRect(0, 0, ctxc.width, ctxc.height);
                    
                }

            }
            
            // initialize game sequence
            await sl(3e3)
            engine();
            await sl(5e3)
            await open_door(100e3, door)

        })();
        

    </script>

</body>

</html>