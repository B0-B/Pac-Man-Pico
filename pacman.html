<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>

        // graphics input
        const   height = 300,
                width = 500,
                resolution = 20,
                wallColor = '#060654';

        // general
        function u(){return Math.random()}
        function fl(x){return Math.floor(x)}

        // format body
        const body = document.body;
        body.style.margin = 0;
        body.style.overflow = 'hidden';

        // create canvas
        const   canvas = document.createElement('canvas');    
        const   ctx = canvas.getContext('2d');
        const   ctxc = ctx.canvas;
        const   r = resolution;
        const   columns = fl(width/r),
                rows = fl(height/r);
                
        // format canvas and add to body
        ctxc.width = width;
        ctxc.height = height;
        ctx.fillStyle = "000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        canvas.style.width = columns*r;
        canvas.style.height = rows*r;
        body.prepend(canvas);

        // build grid
        async function grid (columns, rows, resolution=5) {
            let     mat = [];
            const   c = resolution;
            for (let i=0; i<rows; i++) {
                row = [];
                for (let j=0; j<columns; j++) {
                    row.push({x:j*c,y:i*c,v:0})
                } mat.push(row)
            } return mat;
        }

        // create maze
            // helper methods
            function block (col, row, res, grid_obj, ctx, value=1) {
                ctx.fillRect(col*res, row*res, res, res);
                grid_obj[row][col].v = value
            }
            function free (col, row, grid) {
                if (grid[row][col].v) {return false}
                return true
            }
            function space (col_old, row_old, col_new, row_new, grid, radius=1) {
                if (!free(col_new, row_new, grid)){return false}
                for (let i of [-radius,0,radius]) {
                    for (let j of [-radius, 0, radius]) {
                        if (i==0 && j==0){continue}
                        if (row_new+i==row_old || col_new+j==col_old){continue} 
                        if (grid[row_new+i][col_new+j].v) {
                            return false
                        }
                    }
                }
                return true
            }
        async function maze (grid_obj, ctx, color) {
            
            const   g = grid_obj;
            const   res = g[0][1].x - g[0][0].x,
                    col = g[0].length,
                    row = g.length;

            ctx.fillStyle = color;
            
            // create outter frame
            for (let i=0; i<rows; i++) {
                block(0, i, res, g, ctx);
                block(col-1, i, res, g, ctx)
            }
            for (let i=0; i<col; i++) {
                block(i, 0, res, g, ctx);
                block(i, row-1, res, g, ctx)
            }

            // place the cage
            dim = [];
            for (ind of [0,1]) {
                d = [col, row][ind]
                if (d%2==0){
                    dim[ind] = 4
                } else {
                    dim[ind] = 3
                }
            } // surely divisible by two now
            start = [(col-dim[0])/2, (row-dim[1])/2];
            block(start[0], start[1], res, g, ctx)
            for (let x = 0; x < dim[0]+1; x++) {
                block(start[0]+x, start[1], res, g, ctx);
                block(start[0]+x, start[1]-dim[1], res, g, ctx);
                
            }
            for (let y = 0; y < dim[1]; y++) {
                block(start[0], start[1]-y, res, g, ctx);
                block(start[0]+dim[0], start[1]-y, res, g, ctx);
            }

            // fill internal using snake method
            snakes = 100
            length = 100

            p = {x:2,y:2}

            for (let i = 0; i < snakes; i++) {

                // find new position, if search takes to long it ran out of space, then return
                const lim = row*col*10;
                for (let z = 0; z < lim; z++) {
                    [x,y] = [fl(u()*col), fl(u()*row)]
                    if (space(x,y,x,y,g)) {p.x=x;p.y=y;break}
                    if (z == lim-1){return}
                }

                // fill starting point
                block(p.x, p.y, res, g, ctx)
                
                v = '';
                count = 0;
                for (let i=0; i<length; i++) {
                    // check directions
                    d=[];
                    if (space(p.x, p.y, p.x-1, p.y, g)) {d.push('l')}
                    if (space(p.x, p.y, p.x+1, p.y, g)) {d.push('r')}
                    if (space(p.x, p.y, p.x, p.y+1, g)) {d.push('u')}
                    if (space(p.x, p.y, p.x, p.y-1, g)) {d.push('d')}

                    // throw a die with geom. decreasing probability to keep the same direction
                    if (!(d.includes(v) && u() < 1/(1+count))) {
                        v = d[fl(u()*d.length)]
                        count = 0
                    }

                    if (v == 'l') {p.x--}
                    else if (v == 'r') {p.x++}
                    else if (v == 'u') {p.y++}
                    else if (v == 'd') {p.y--}
                    else {break}

                    block(p.x, p.y, res, g, ctx)
                    count++
                }
            }

            
        }

        // initialize instance
        (async() => {
            const _grid = await grid(columns, rows, resolution);
            // ctx.fillStyle = wallColor
            // block(2,5,resolution,_grid,ctx)
            maze(_grid, ctx, wallColor)
        })();
        

    </script>

</body>

</html>