<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>

        // graphics input
        const   height = 300,
                width = 500,
                resolution = 20,
                wallColor = '#060654';

        // format body
        const body = document.body;
        body.style.margin = 0;
        body.style.overflow = 'hidden';

        // create canvas
        const   canvas = document.createElement('canvas');    
        const   ctx = canvas.getContext('2d');
        const   ctxc = ctx.canvas;
        const   r = resolution;
        const   columns = Math.floor(width/r),
                rows = Math.floor(height/r);
                
        // format canvas and add to body
        ctxc.width = width;
        ctxc.height = height;
        ctx.fillStyle = "000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        canvas.style.width = columns*r;
        canvas.style.height = rows*r;
        body.prepend(canvas);

        // build grid
        async function grid (columns, rows, resolution=5) {
            let     mat = [];
            const   c = resolution;
            for (let i=0; i<rows; i++) {
                row = [];
                for (let j=0; j<columns; j++) {
                    row.push({x:j*c,y:i*c,v:0})
                } mat.push(row)
            } return mat;
        }

        // create maze
        function block (col, row, res, grid_obj, ctx, value=1) {
            ctx.fillRect(col*res, row*res, res, res);
            grid_obj[row][col].v = value
        }
        function free (col_old, row_old, col_new, row_new, grid, radius=1) {
            for (let i of [-radius,0,radius]) {
                for (let j of [-radius,0,radius]) {
                    if (i==0 && j==0){continue}
                    if (row_new+i==row_old || col_new+j==col_old){continue} 
                    if (grid[row_new+i][col_new+j].v) {
                        return false
                    }
                }
            }
            return true
        }
        async function maze (grid_obj, ctx, color) {
            
            const   g = grid_obj;
            const   res = g[0][1].x - g[0][0].x,
                    col = g[0].length,
                    row = g.length;

            ctx.fillStyle = color;
            
            // create outter frame
            for (let i=0; i<rows; i++) {
                block(0, i, res, g, ctx);
                block(col-1, i, res, g, ctx)
            }
            for (let i=0; i<col; i++) {
                block(i, 0, res, g, ctx);
                block(i, row-1, res, g, ctx)
            }

            // fill internal using snake method
            length = 100
            p = {x:2,y:2}
            v = '';
            count = 0;
            for (let i=0; i<length; i++) {
                // check directions
                d=[];
                if (free(p.x, p.y, p.x-1, p.y, g)) {d.push('l')}
                if (free(p.x, p.y, p.x+1, p.y, g)) {d.push('r')}
                if (free(p.x, p.y, p.x, p.y+1, g)) {d.push('u')}
                if (free(p.x, p.y, p.x, p.y-1, g)) {d.push('d')}
                console.log('test', d)

                // throw a die with geom. decreasing probability to keep the same direction
                if (!(d.includes(v) && Math.random() < 1/(1+count))) {
                    v = d[Math.floor(Math.random()*d.length)]
                    count = 0
                }

                if (v == 'l') {p.x--}
                else if (v == 'r') {p.x++}
                else if (v == 'u') {p.y++}
                else if (v == 'd') {p.y--}
                else {break}

                block(p.x, p.y, res, g, ctx)
                count++
            }
        }

        // initialize instance
        (async() => {
            const _grid = await grid(columns, rows, resolution);
            maze(_grid, ctx, wallColor)
        })();
        

    </script>

</body>

</html>