(async()=>{const height=300,width=600,delay=0,resolution=20,wallColor="#060654";function u(){return Math.random()}function fl(x){return Math.floor(x)}function sl(t){return new Promise(r=>setTimeout(r,t))}const body=document.body;body.style.margin=0,body.style.overflow="hidden";const canvas=document.createElement("canvas"),ctx=canvas.getContext("2d"),ctxc=ctx.canvas,r=20,columns=fl(30),rows=fl(15);async function grid(columns,rows,resolution=5){let mat=[];const c=resolution;for(let i=0;i<rows;i++){row=[];for(let j=0;j<columns;j++)row.push({x:j*c,y:i*c,v:0});mat.push(row)}return mat}ctxc.width=600,ctxc.height=300,ctx.fillStyle="000",ctx.fillRect(0,0,canvas.width,canvas.height),canvas.style.width=columns*r,canvas.style.height=rows*r,canvas.style.zIndex="1",body.prepend(canvas);const _grid=await grid(columns,rows,r);async function block(col,row,res,grid_obj,ctx,color,value=1){ctx.fillStyle=color,ctx.fillRect(col*res,row*res,res,res),grid_obj[row][col].v=value}function blockFromCoord(coord,grid){return _grid[fl(coord.y/r)][fl(coord.x/r)]}async function clear(ctx){ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)}function coordIsFree(x,y){return!blockFromCoord({x:x,y:y}).v}function free(col,row,grid){return!grid[row][col].v}function space(col_old,row_old,col_new,row_new,grid,radius=1){if(!free(col_new,row_new,grid))return!1;for(let i of[-radius,0,radius])for(let j of[-radius,0,radius])if((0!=i||0!=j)&&row_new+i!=row_old&&col_new+j!=col_old&&grid[row_new+i][col_new+j].v)return!1;return!0}async function maze(grid_obj,ctx,color,snakes=100,length=100,gaps=2){const g=grid_obj,res=g[0][1].x-g[0][0].x,col=g[0].length,row=g.length;ctx.fillStyle=color;for(let i=0;i<rows;i++)await block(0,i,res,g,ctx,color),await block(col-1,i,res,g,ctx,color);for(let i=0;i<col;i++)await block(i,0,res,g,ctx,color),await block(i,row-1,res,g,ctx,color);for(ind of(dim=[],[0,1]))d=[col,row][ind],d%2==0?dim[ind]=4:dim[ind]=3;start=[(col-dim[0])/2,(row-dim[1])/2],await block(start[0],start[1],res,g,ctx,color);for(let x=0;x<dim[0]+1;x++)await block(start[0]+x,start[1],res,g,ctx,color),await block(start[0]+x,start[1]+dim[1],res,g,ctx,color);for(let y=0;y<dim[1];y++)await block(start[0],start[1]+y,res,g,ctx,color),await block(start[0]+dim[0],start[1]+y,res,g,ctx,color);let p={x:2,y:2},br=0;for(let i=0;i<snakes;i++){const lim=row*col*100;for(let z=0;z<lim;z++){if([x,y]=[fl(u()*col),fl(u()*row)],space(x,y,x,y,g)){p.x=x,p.y=y;break}if(z==lim-1){br=1;break}}if(br)break;block(p.x,p.y,res,g,ctx,color),v="",count=0;for(let i=0;i<length;i++){if(d=[],space(p.x,p.y,p.x-1,p.y,g)&&d.push("l"),space(p.x,p.y,p.x+1,p.y,g)&&d.push("r"),space(p.x,p.y,p.x,p.y+1,g)&&d.push("u"),space(p.x,p.y,p.x,p.y-1,g)&&d.push("d"),d.includes(v)&&u()<1/(1+count)||(v=d[fl(u()*d.length)],count=0),"l"==v)p.x--;else if("r"==v)p.x++;else if("u"==v)p.y++;else{if("d"!=v)break;p.y--}await block(p.x,p.y,res,g,ctx,color),count++}}for(success=0;success<gaps;)[x,y]=[2+fl(u()*(col-4)),2+fl(u()*(row-4))],outside_cage=x<start[0]||x>start[0]+dim[0]||y<start[1]||y>start[1]+dim[1],outside_cage&&!free(x,y,g)&&(!free(x+1,y,g)&&!free(x-1,y,g)&&free(x,y+1,g)&&free(x,y-1,g)||free(x+1,y,g)&&free(x-1,y,g)&&!free(x,y+1,g)&&!free(x,y-1,g))&&(await block(x,y,res,g,ctx,"#000",0),success++)}maze(_grid,ctx,"#060654",snakes=30,length=100,gaps=5);const canvas_active=document.createElement("canvas"),ctxa=canvas_active.getContext("2d");canvas_active.style.width=columns*r,canvas_active.style.height=rows*r,ctxa.canvas.width=600,ctxa.canvas.height=300,canvas_active.style.position="absolute",canvas_active.style.top="0",canvas_active.style.left="0",canvas_active.style.zIndex="2",body.prepend(canvas_active);let pac_v="",pac_p={x:0,y:0},pac_s=0,pac_mouth_states=[.2,.5,.8,.9,.8,.5],pac_direction_phase={r:0,u:Math.PI/2,l:Math.PI,d:1.5*Math.PI};async function draw_pacman(coord,mouth_state,direction_phase,resolution,ctx){rad=fl(resolution/2);const c=[coord.x+rad,coord.y+rad];ctx.beginPath(),ctx.arc(c[0],c[1],rad,mouth_state,2*Math.PI-mouth_state),ctx.fillStyle=ctx.strokeStyle="#d9e312",ctx.lineTo(c[0],c[1]),ctx.lineTo(c[0]+rad*Math.cos(mouth_state),c[1]+rad*Math.sin(mouth_state)),ctx.stroke(),ctx.closePath(),ctx.fill(),ctx.save(),ctx.rotate(direction_phase),ctx.restore()}function set_pac(coord){pac_p=coord}async function move_pac(direction){"r"==direction?pac_p.x+=increment:"l"==direction?pac_p.x-=increment:"u"==direction?pac_p.y-=increment:"d"==direction&&(pac_p.y+=increment),pac_s=(pac_s+1)%pac_mouth_states.length}async function can_move_in_dir(direction){const[x,y]=[pac_p.x+10,pac_p.y+10];return!!("r"==direction&&coordIsFree(x+tol+increment,y+tol)&&coordIsFree(x+tol+increment,y-tol)||"l"==direction&&coordIsFree(x-tol-increment,y+tol)&&coordIsFree(x-tol-increment,y-tol)||"u"==direction&&coordIsFree(x+tol,y-tol-increment)&&coordIsFree(x-tol,y-tol-increment)||"d"==direction&&coordIsFree(x+tol,y+tol+increment)&&coordIsFree(x-tol,y+tol+increment))}async function keep_moving_pac(direction){if(direction!=pac_v&&can_move_in_dir(direction))for(pac_v=direction;direction==pac_v;){if(!await can_move_in_dir(direction))return;move_pac(direction),clear(ctxa),draw_pacman(pac_p,pac_mouth_states[pac_s],pac_direction_phase[direction],r,ctxa),await sl(30)}}async function draw_ghost(coord,direction,resolution,ctx){const c=[coord.x+resolution/2,coord.y+resolution/2]}increment=4,tol=9,set_pac(_grid[1][1]),document.addEventListener("keydown",event=>{var name=event.key,code=event.code,d;console.log(name,code),"w"==name||"ArrowUp"==name?d="u":"a"==name||"ArrowLeft"==name?d="l":"s"==name||"ArrowDown"==name?d="d":"d"!=name&&"ArrowRight"!=name||(d="r"),keep_moving_pac(d)},!1),ghosts=[{x:start[0]+2,y:start[1]+2,c:"red"},{x:start[0]+2,y:start[1]+2,c:"cyan"},{x:start[0]+2,y:start[1]+2,c:"orange"},{x:start[0]+2,y:start[1]+2,c:"pink"}]})();