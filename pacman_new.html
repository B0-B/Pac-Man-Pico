<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>
        (async() => {

            // graphics
            const   height = 680,
                    width = 960,
                    mazeWallGapRate = 0.3,
                    mazeWallLength = 100,
                    mazeWallNumber = 100,
                    resolution = 40,
                    wallColor = '#1b0f9d',
                    retroBg = '#121212',
                    maxFrameRate = 60,
                    coinRotationRate = 1,
                    increments = 2,
                    pacVelocity = .5, // px/ms
                    bigCoinRate = 0.01;
            var     ghostVelocity = .3;

            // general
            function u(){return Math.random()}
            function fl(x){return Math.floor(x)}
            function sl(t){return new Promise(r=>setTimeout(r,t))}
            function canvasOffset (canvas) {return [canvas.offsetLeft + canvas.clientLeft, canvas.offsetTop + canvas.clientTop]}
            function au(b64){return new Audio("data:audio/mpeg;base64,//"+b64)}
            
            // inject font data
            const fontCode = "url(data:font/woff2;base64,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) format('woff2')";
            document.head.insertAdjacentHTML('beforeend', "<style>\
            @font-face {\
                font-family: 'px';\
                font-weight: normal;\
                font-style: normal;\
                src: " + fontCode + ";\
            }\
            </style>");

            // format body
            const body = document.body;
            body.style.margin = 0;
            body.style.overflow = 'hidden';

            //  canvas
            // create layers
            // Layer 1: Background Layer
            // Layer 2: Interaction Layer
            // Layer 3: Dynamic Layer
            const   r = resolution;
            const   columns = fl(width/r);
            const   rows = fl(height/r);
            var layers = {};
            for (i of [1,2,3]) {
                const el = document.createElement('canvas');
                const obj = {
                    canvas: el,
                    ctx: el.getContext('2d'),
                }
                await sl(.1)
                obj.ctx.canvas.width = width;
                obj.ctx.canvas.height = height;
                if (i == 1) {
                    obj.ctx.fillStyle = retroBg;
                    obj.ctx.fillRect(0, 0, width, height);
                } else {
                    el.style.position = 'absolute';
                    el.style.top = '0';
                    el.style.left = '0';
                }
                el.style.width = columns * r;
                el.style.height = rows * r;
                el.style.zIndex = `${i}`;
                body.prepend(el);
                layers[i] = obj;
            }
            
            /* Sound data */
            var sound = {
                mute: 0,
                eat: au("uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAEAAAG7QCJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYnExMTExMTExMTExMTExMTExMTExM\
                TExMTE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7P////////////////////////////////8AAAA8TEFNRTMuMTAwBK8AAAAAAAAAABUgJAXIQQABzAA\
                ABu3MfUz7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//vAxAAACvABb1QAACsaqy\
                x/NYIAkKQtNxyXcAAAAzAAgAAAHj3/gAABn/HDx/+AADv6Hj//gA7/9///+/8w8MABH////4AAB/9Dw////Dw8PDwwAAAAQHh4eHpAAAABAeHh4fgAAAB\
                7YeH/oasDEDACIDMFQNBo6K1zQCIkgdaRkrqh46wC6seGmQRBcCKCYEFt6jwUCOWhDRGBUPqHyBQ6GwMNrCc6IkBtdT6cJRzNJ+XS5z0qVv2dwQt7irnS\
                W5SLUalBEC1oDe+SS/B5oAaxWdOdem/BeohflGMe+V1I9A0Ri1uRx+OSekhV2FUsInIIntz9yW1at2X1p+1L4r38bnZmzBu+fnX+gzqT0FwJPZfv/y383\
                //////8RnrH/////VyyrY41csq2ONUGv/+xdirrgHN0IzgJUbAlIiG0pAXHRoa+1LgdJPkqlDLA4TrpEzKAd9h2kktCkAoljpHaajNubIhgA9cSipJA9f\
                Ca7j28+w2X07atGh9tYd9tPmotWW/B82uWxy65vc+odX7P9xz/T/0V/5K4/g78kAAAAAAAAAQV3YwBTuAJUPCBZZeQWmXZbsixX0UiU43HsTlsJSpULcF\
                yvEDVT1nPwoFue6gTiOmZ2d8fqofw3BvOFkh77KRtFwQG/aAZLG1zb7+S9/d9fxH3mOjj72l0Pykd+nBf/gbXwQbn+tFnvg2mAQMBAAAAAA4NayqAEIMx\
                GkjEgeNAoEMZok++zsIYwI4kYpkfd4UhoRnFhILxPRlcyEE3VxjsadhXGEOtimuTQQnJ2Aj7ziHFk2r1ZTRzWZ+fQ73bYc1hg8nHHz7ZyTX8w1Os2c+ZV\
                XcZMlNH/RbrNnyltN2Fbjyv4T+8OAzu9QIQfrPwwkpkQAAOl9jKguUrFHkei9TSVKGgx9dpNKoIiKTTE6es0BCmYMX5MfhV1Cr1W+HsxsYVY3GX/jbKqq\
                qqX9VSqq3/GY6q/r3/+3DE04ANJQtn/YWAAcYgavmHmXlmq7H/D9moUOp/g1BVwhOz0ipMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqQAABIdVMQU1\
                FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//tQxPgAUI0NWewx8eFkH6u5hg1UVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVf/7EMTYg8CMAR6gAAA4AAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"),
                die: au("uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAbAAAcnAAbGxsmJiYmMDAwMDk5OUNDQ0NPT09PWFhYYGBgYGpqampxcXFxfX19hYWFhY\
                6Ojo6WlpagoKCgqKioqLGxsbm5ubnDw8PDzMzMzNbW1t7e3t7l5eXl7e3t9PT09Pz8/Pz///8AAAA8TEFNRTMuMTAwBK8AAAAAAAAAABUgJAVAQQABzAA\
                AHJwAUeNiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//vAxAAADAwbZVQwACrSna\
                o/M6AAAAIQtWPbdERELdwAAEII6GAAB48AcAf4eHh4eAAH//5h493////xwD////8wAAAAADDw8PDwAAAAADDw8PDwAAAAADDw8PDwAAAAADDw8PHgAAA\
                AGw8PD3oAAAd/Q9/gAAAABQ5EUU8ZGrbkT99AgEMgXGJgCt9gBMWlNsUSOCQS+ZwgAq0uKmmEZkgrEhUsZ46VGgkmJHgcWMo9DKKOZvXJ4AxjiJgjBgAZ\
                aZAyWoSV4hg8IMmNAgAI+zsAQA8L9GKIsTR9pQYYIhSRdm0qZM1/o1zVPfvS2V/R0ExKYhNyKBoZgCklr03N0kD2ozLJt992rTfz+NDcqvwxzVv8dflt7\
                P7///+6ok9iy4r/8rColhUqIvYFMEQABkAA3UdjDJC3QFaEYx6smKKkqzdE0BerqRIfmKKKs2bYyEiCDABZxAIkHKAxSCMgwhUi5oeUTLMkaJdZ8QBIGX\
                DxqTKJoeb6zapJIu1osdRMkkiYLazA0ZTZMkONWL5dOVHUl/X/////f/l88dm6tPgsX/1/Ne4KYQoAdgAA16ElGJu6gloKSI/pxOssolcSDFrUklrO8ph\
                Y3fdolKHi6n3DvA/1vRPHoRa9/hwgWj7+vpilK57Atuw7+s5n4eZWERomQ0WAF0aYXZbCSGQwBP//////L/1CL9f//tUo0UDln8mpIfJCyvsCUAQABoAA\
                V0xhFJZahgweYNhhw9uSE1UoNLGlEq1yDO03V/M5TVC5IBR2pyDsswhujwoYMZNFJz0w9xe3vnKwRSUAQNK6rWGlf/J0nGr/k+gWcDu0jRIdShwmUdJX7\
                Rtr2BKLDO/////+j/9Cb//rCQY/BYnLoWx9wAQEEIHcSAJ+qZTVryGkqCIEypwyrV/GxXBMVH9gFjN7e2eSssba/KsNwItSLWN13QUpysuGy757ko//3z\
                HGhXXS16+MFSCb/8v/+3DE2IAPXStP/ZmAIcYsan2XllyhW0Q1XqR7jQ9ayDQku4p+P4JMCeY3/////3/8SDuen271/5g1vq0z6MqbWaiMOnX5AbAGQDl\
                AAOuDgk9FhEmqYG2CS8mEAAAFf0QImYBAmT2Spuax4fjMHqokRBmhoD6sOLuak0CObiV93nHDIEpv0Sw/vP1SElAMTAEAiSVyhnn8hcHl2qWr0tJ/pdyx\
                O23CrI2/6oKFSAYVN/////8//EhcN//g0BidvwmNba/pELcJcAIAAH+U1BQTmIV0QqEGxsXRsMAAc9HcwdXvbXe3FK0lA61iAdyouCELYPKbfKAA8JzrE\
                xJcq3/3ZhcASDsbuqUPuuYzuNWQwgWRkao6cp2OihlEsmxk3////+3qY3/UCQ0JpuyPT//+NUDH12rF1dlg//tgxPQADzUtT+0s9yHoNCp9hB9UtgZAFA\
                AAb16k0ZOg21QkSbvSF9EAbSXFECidVlc7tTMTTzl8o3UnwZUbHKY3vJo67resvj5NU7KZd29aJ4uimgldMlmLh2cQuPT6DMhJTBpFzTVIyIUXOJIoLyh\
                L///f//8r/+BeYqlaNpY29W//kbsZ0yZtn2oSIKQAAAALWIQSNqORQIJQQ4HMrRfpcg6G6xowJo55VgyoG33Xh1m8fuV6pboapF+3lh668acrH8d/J8gR\
                m7P3oNtv/GTVwCgQwRB5YYh9QG85fUcO8biCPDeSdy2NyR5U3iGKpC4ukw0Xb////9/yf28qEIIPTHXs//tgxPIAD8EvUeyktyHNLip9nBz0SH1/zp9qy\
                /rq+hBAAAAAQABvDNrg/hsLxFUEL7iMUNuHgEtgoHAAE4AOEDAzcwtaYI7FSgn6BT7Wn1CoKuJfZkUO6sXqRDU+jDvkrjcbaPMavVabdux38O3YfvY5vN\
                BbZSYNkOPwbIXRW0bmX57b2ZTmVpT11k9Uu5LZ04GNPlQKik///r//18v/zB4QgeINzjzP3Q7/+jxe0ru6CHyAwIMYAEgAP6Y6CHhBjDy3EFiAwDhpH4e\
                C1z0ABEQ4tQ1pHnblDbn2o63NrIUAwwyWGV1DTlPFRbuU0PSS1rViW2O6u4zFrv5XeJ0Nd94VQua///tgxPEADu1zUew1VqIOqCl9pZ7kz+DlOHn0k2sU\
                UQ7vUQdONitbIMwf5MOlwcDP//1/+vzDlv+oaGpppZjdWY7u//5Blga9UWWWygOgBQADAAFt0MQQC9Sh7wBaIoLk5ZQEkqViFVGHL6sEtH7nQQG5xfQaC\
                2cYOLNaCFuyyCB++M4uFsPHABGQt5Nf+nJal3CwhlXNpKnxyavGlSe4uEQJij/////+//Vxq2e/4sAzW/peE2KYV/AhwmAFJSQBllYUBSpSAE2cUg5bXU\
                uSAKySdZUC1BkDmBUnfxqjpRqssl2cfTii34GAVCAPq21OnPVuf0AAVmuklHf+oQFEqplRB5F6//twxOuAEoV5Q+2xXEIjrWn9tJ9Uhq3Mc76CboSg4d/\
                ////+n/r////x2/06MhUqvwIgRQAnAABZmUjojUppcEniC926teJSGoQQ5hbwRtsSPrTMZOXMADxIOONAsSQd3pxW3r8cS5OfIo/vJfA+XgqbPK25v/xr\
                wNHOP1JOXUOgiBuPg0VO5Oewg+A6OSJDv//7/B5//xAVT+SQ55NRI4W1QdgpQVmEQAPmiFr6JVccAA+iUAqpspf0P1QBAS+StqD8thmbjQxZOMX7MhY3A\
                LqlfQF8sUS2Yef/9eBlkMMqIkWqnT2MFfTUWsqhwhqgMioYOuQcdyK9AO/V1ar///////+HX6N5PTptx2a9eityy6r5CRKYATjTBW/TuGcvABEkEHPAxi\
                Yr8jrStjXUSWGpHqted95l/P/7YMTvAA2ZMVXsoPOhnaxqvYWWlChzXi7kjjcdtxGJJqsVh6v9FlGovBkbSaWqMXe2HNl7kzrffPLVt8QPjnOuxBHMCK5\
                jCvGeFm/////+v/EBZ//kDqv+vNJ9goAcgI2YQQP0zDEzAREGMMeR5NoXYCsUobbZ6VHeTbgNgBbgWFSakkUgbzdct+kUb/4NB0C0d5MHszEYfjT5zugs\
                RsxGaHZMO6HUUWgTF9BvK3Vv//////9Q8/T//6u7d///6txrq7cGAGIAJAEDfeBSoCViAQJ4EILWrBt0Mgy0cDUL0tRpYlAyDSC7L4DHkVk7fV1Ritvf/\
                eyCyNcjRl5SXXn/ibslz//7UMT8gA4ov1HsMRShxiwqfYeWJAzlnEiSSVdTsm5GIRX/oY3U5f9P//0d/4Un/5Uq1/+VqGKn0bAxIU4K+TIP+6ZQ6tuRUW\
                SIFCjgg7KPossqwvCTnZReHAMlSKrTY4uPEmeuy2i6NiV3ADvr9MNP8+f5exy6lRvF3i4zQn4ybTSgmXhLQd1Yw1rS/+Iv/oX//+r/6iL//k9/t7yDocr\
                4AXCCACZAAeuFh5kAJdNYURgifUpJpANAioUq02Vg4E0tH+XMs1VpgAfNYeFjHZT/+2DE6IANiStX7CyxoZ8yqv2FllxNoSUJEVprzRGdwPL92a37wyz/\
                9x1gskZZhfiMs0qM//OnSBTa7fnU5MmFEdFEO1nYUAiStMK/87+n////9v+gt////rU9WZf/f9HoRAqU/AGwKIACIAAdgCbg0leKAsMHcCQyiyig0URTS\
                IOvCBpfps97CVuwIXgsYYJna2Gmo7afjTQSjvmkO+oUn14K1BCPqNuZI7AqPn2/zuXbhEc4kqTm3qzKOp/h9EJ6+pizks4tRgJ7nWIIsEx/X/////f/wU\
                WJr+vvt6sr//9K9vEx2er4AWBUABaAAMtGBCcJjQXRbAbJhRBExAArpPU4Fgf/+1DE9oAMvSVV7CRRIZqlav2HliQBFp2nbHH/7fggHDETG+1oDXJz0rp\
                yCWcUh9Yf3pmf6F49Bme5s7TZ6Zndcos/WnNpFZ21lDT5keHbntbHzVvmAmA/AOHC2//////b/Q4XNqaZ///U00uv8ovnU/oHAExAJgQAt4dSIUBEGXWp\
                SxGmi96elp9AKeoPF5ySNjUwtyuWRFNsMcXReij46GfnZooL1Jf//vOAQn2xeaq3X/vpz8+6pqtjH8rtKVqRVv7+FQAriP/////2/8Kd//twxO2AD+WfS\
                e0YWooIs6k9p5Z1////1UQJKPbY92+nAoAHABUBAF/LTR+nCwtDFRJTJB0JAjY4tCJ1PZbJaa/hi79M+xQlnYvGaMdC4nlqQsVXWUVvd/qEblYVXEgI0O\
                2Pp3ccVBkuiPI6qZ0RUFNN1Dv/////6f+Jh0HdT/7AUAd/qcvKBJAWEAdSAP/XMghhwkHAQl0GDCEjCViCoSgCwrJaq7WxZ7pXhXaPSgJhz9GRhlsPiEo\
                p2Rlm7P1v0zhWFr1/lk1PZm32tlFyktVP1CIMXcD9UK/B+cHGv0/////0b/hPUpmb2//0P6I/+T7dxMmo2uoHMJYACQECbdhxbllxEx0xdQlpvJ0dCF3q\
                RLgxtc0MJ05/WVsLYKSs/XJ457FYnEq0Ol07ln/SJEANZuzmSF/8q//7UMT+gA89aU/ssPVhqKzqvZWKdCnJR2d1ZzD3Hm7zGypZdQDhCF93//b5R//5H\
                +tb+AAAvYCICpBH7bAH3RpEZG6o3LZBzANUYXGEOAdT09GjtiGjMQYjj5YEoTAVrAeoMhOoFVzAXK62h8S3zV7u+7l0ENbodny4rDMZX5B0a0cyq4xHMg\
                Ukdqz0B+xepv/////7/8Tb///8a2/213JfeL36BAB0AjjAAUtIqTtYGRwcYMABPpWAr9/hgoWXlDwzSDC6a07K2shm9JBcDsL/+2DE6gAMwTFV7CSy4cI\
                0ar2GFmRSOG8q7Nc/Yn2Xz1+JZ3z5GkkOZCtwbXcdfVp4xqtElF3ULQPlZzmONiAc4MXh7q/7f////X/ibqf+cDX/8nvxwYAYgAigAeNG4mQLMjiBAUL8\
                oRlrYWOQFG3FjQgUChmNtgXXRBo1m2BQQ9vPkUnfwPMfmw6xvGsWgGv5VMkK+fbJtv4N68lmzzqFg1N71RANh4VRJg57fRM4BCn+M////+AuRr+smz/66\
                CbECQNgABQAA9sGSjODZ4Msmm2HGmOQg+hMOEAiOmW7JULtxmEbwEoBjovDsbl1rpQvQ+ZuEZfkBMCYoAaB7LEmtOfZjb//+1DE9oAMUMtX7CVS4bSr6v\
                2HliQ5CVQwxc2makFEGlA1qVZ+tq9/5ELtSQYAxNXrHf2f6eUDP/h8j//+S5AUHYBBYASL/whyhskCwh/luAxEoROV8nbE4ol3BlR9xGdW2IWbg7vsaQf\
                tKHIQ/TFZs8at9Jeoze6S6z6GYpKRTHivWnnSM2r3pOvo8BsCNhwMoMQnbp0X////t/Ubt///UtTq/29qutn1t/MdNbIJCXABdFAJf1GVEClGSG8NMMvT\
                5M54kXhZgylEp49L7FrC//tgxOwADYknT+y8sSGupOm9lZY0RmgVhDnQqaJCE91fv6oGR/NQtefnDKGKtYg7FuSrRkxn3I+Tz5o2kg+R6E09wMFxrocf/\
                ///9/6F/+n/l89/7+zo6QYKcARUAAEN0/AZFnxhYCcPa7ww0RJKIIvEQ6Qu1GeOikSNUz1krG8t+lWAQQnYstPTOGRkK0bf+dZZ3MRM/mDyMUKtmtlXfI\
                3us9zfpAcN246X//////yjv+Gj/+mQch/C8VXJCgdgA2yAAI/eYwDSQIiNFI3fMUAxBCqGkiMFMtkBmqK1S7gYV04cV1XufWx+yN/VWczff0wHSa7Wr+K\
                3Jvj2axudkIIAehSc//tQxPgADbjbUeyh86G6s2q9hLYcaBLxY+IpK5vOdB4d8Y//////+YUJt//8cf/9//en+NJwfzgoM6gkZRA4flnTWpcprYCIJBN4\
                sNGQdoOy7kSdtZVMydl46AWXnUpndb61J4IEIoEjln6uEot/q1JLbCXuyY8BRF5sXcIsYW86tU041l8E0hY9s9mxkz5Thzlf5dwGDDtuKg/+/////cb//\
                /NCe/9V/1alQr6FE6gKAUMDbkgDD+fQRN3CgAFmUEbiCAm6GIuW/eeIWWUwPf/7YMTnAAyhT1XsJU9hkiRqvYYeVOhayjLALQMsdR6mhPo0yB4BbxlbE3\
                7qZS13v7QxVOHTIJidtKNr7/Jr1BW4X2bnLkXRpR2CBhISNMR6ACdS8/2VP/////4UQ7/0DRfyVNQ95MmZUGAaxgZweAdYkQFV0wiIrxEA1UgWMOMlOsR\
                5R8FxdMU2m20+3+JVdIUwWSLtUoL52aOmyCyTYKjvtiurQIoOIk+oWXD9cKMs5TMx3I9YoZo2iUBi/6H+n////9v+n///8H9v+nq9mVvH2wQgpQEYQgJf\
                keRgTli5LprgPJWk9ySwFgJILf1kwH+TXx5UTSFjoaRexKolDFnWoGaXI//7UMT6AA1Vm1XsvKup4bHqvYWLHJy1cruv55HaWgT3r2bmzN1ei9rjkto2q\
                PqTdp3x3873UbNt7/5Cdjr6H////+v/y6fbp///rRUaVO/3yDVeoPAEIAEQQACogFppVSqChw4lUEiCqKUwJAIXFBKBSFqYtrUmqbNuZVej2CGWv8p1o0\
                NvlVVVf7xz2FzV7HG59Xv3KdTCaa5SXqosHJo2vhRoWCsIjnG07A+Dh6pQKnlrJO/UGL9AKb///////9P///9Ffv/7f+MJKukGgIb/+2DE5gAO4SdT7KR\
                W4Zgzqr2FipQAO8sB7ZIoBEqBIovESxDAUvQgAyMMCMseKVhdmceJqfcbr+kBsCVdymqph3faz6qkwtM8XS/s7nV5j/6xzjTE6XnsSEDzf5JJlPS729Ks\
                0Oc0qh5ZPRHqLzgTfX/////3/8m3t///vL93p7qe4BMAQAKUIA/YhISXAZwVFRc7jHgw/DaXiiphIyf9uu2Kmliq5ctygYVikvrTkUn4zL5RKbTcY3Jnq\
                b7sEy+5YVsADxwQIZojIhNkpI+PiuiZOgWzEa+8egdYBwTVtBeWHhT/////9GN/Ixw7rd6ttZH+hKV1KvoJAHYBORtJj9G0jOX/+2DE74AOLWNT7C23Ie\
                MzKP2kF1HVBQnBHhAibHYmFCK+ygpgytsAv4utpCsDBqXFjbtsx3p/65Wdw4MAUH0lWh9iM97MwiFluSjEZ1BmFsYLIhkcsBEmRoUlDg3t6E//////84r\
                /7Q7/+q3rCQuAFk7TUw+YKnuh6TVGWUwqMIIqmqEVQX6pkbod3pqocWWWtJpPxD1ZpNqdGlG/w4bgMrKHi3ltT1rxUOOtaF0WCw1NCtz4wP+sU9lGuJWQ\
                3+r7IrxIAizmf//T/5T/+zrq6BYJcENGUQkOHAHFvcBFDGXtnxkojTCSUDS3qSpaz8TEY0126YOg3Gi/xBPgfcd/yQCwHQr/+2DE8gAOEWlV7KD6Ydklq\
                n2EFxShhb0/5c9Z3y/KlvRZv9InnXWLNHDxJ2H2/EAP0A3//////EH/8M0oWMwCtTdae3EsC4X0L7iSrZfE4kLQRlV76J+bbJg9akr1JeaHWr9eh1qj6U\
                /ftfrDDbP538aDnWGIc6gILEiassXVRwEXKjUDNRQuI0le6rqfksDm6y7t//8h/53CJRZgVpbTTW4YEYFyodaPMqykQMHh1WhXGL0kGPEohSj+MQYs+4V\
                sRtL+zenLgTRWlQ/uX37nPYx0ihi+4iLFjBXl4lRRbQ84qAYo+Ii3///T/0eQwDqLTVzbdADKQ62BIcoTiXvNIgmpS9n/+1DE9oAMgSdZ7DBRIY0aqz2F\
                olzerrDkD8L/thKIi5E5cILFj2fb9atc8UkoC40YACKtye4i6k1uWt7EK70TQ1qZp5m/GG/fA0adyNZK5erwESkANpTSSgAkTYsxgpQHVUZANHkqEltc+\
                t2U2ZRdEQWUs2FTe1Jjf/AVPiflNzNz9LRS2c8GXbPVeMMUJvCv5p+WAlWoVC/SDcvIajkA72H5HAAt4v7bEARslmmT2VitO6qs1p+ICsZBABADC4ENKs\
                nAgUePb//ciZV8cq7d//tQxPAAC3UlVewgs2F1mms9grccGFFV01VqlKRh0ylaEfnJLeh+uoCJ4oXkqpQpGoBXnXW1gBMQEGhhShYXi+GWLC3mCQ3Pum/\
                e7rqlBoaE40a83H1RI/7X3DTwpGb9K7m7u6O/98tWiJW/+NJeOan1Ph9/DKml/1TwAqs6NLpDK7G9mpCAAAAABhQTaGktlrVzNFMKYC4AIDGQEF0YCXu8\
                ZfQzB1IpMYKknxCyxqU5UUaCvJuaAzVbCfLLUaR3qwu7fmNBe6xfcQwDIPSAef/7UMTxAAp0yVfsMK8hTpdq/Yeg/ImWLby9KqNqNBeop5Eq/l/LDxUFB\
                ADre/qDAPgQMf+D4EOA+UZ//D5SPkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTE\
                FNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+0DE+oAJXM1\
                R7CRvKTGZKn2Eiayqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\
                qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7U\
                MT/AAmUyVH1hYAh/JJnPzTwQKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\
                qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\
                qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+xDE1gPAAAH+HAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\
                qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="),
                siren: au("uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAALAAAL5wA8PDw8PDw8PDxWVlZWVlZWVlZqampqampqamp+fn5+fn5+fn6YmJiYmJiY\
                mJipqampqampqam+vr6+vr6+vr7S0tLS0tLS0tLk5OTk5OTk5OTz8/Pz8/Pz8/P///////////8AAAA8TEFNRTMuMTAwBK8AAAAAAAAAABUgJALAQQABz\
                AAAC+dIdwzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uwxAAABCQBQ7QAACI0\
                GCh/N5IAIAABb+n8AABQEFg+8HwfB+oEHR75cPwQdW/ggCAYlHcPnKgANVDFAIkyy01iUAAAAJoGGoaaph6Ih+AEQzIuBoaYxKGvhZisATnRmZU042VUD\
                j0HXYsOUqdzfjoL8kRJpABgd8SfbhwHUs9/5exg0ALUGlQQDa42UbgOO/1K7Zf9Z7Ob8MF7BkN2LUvTnGS4Ep/qTzl2ZRYmEcErJLX5E4da93////vP//\
                +Ed1LFqvvBAnqACHAz2hTJ0VE0FUOJnhbSgqEMKPGw5ZJazI0zYzYcqeRMVlSah3CNBzxh0j7umv3ompkMMJ+AxTA1bWzE2qiXUEjp5L9Eva0TXjAeRB0\
                Zv/uyKL/WYf85/kP0yG4xALfKg0CTKw/iEtExYy5G6u4DQUVJThw0ME5WCfW2QT0/V1rdTrbTEqeZVg8znUdzRzT9I3RJ4V4pqRL/1orqSuRRvUouNW6R\
                o/VmZnQQQMk9//kQTgOQUOHP8GDn9H+i/pgEjJIoIsZYIMfWBAwJgCty6kZVqm58osv5Phurmsxfx/15Ku0pkVKYXkNJaaaab/XolMc0EshTSYIMTH60U\
                kWHWaFAhonhRcN1oapFd2cgcp5dv/EA6JQx7v8V/7/9OZIAC4whyAAWxK2AISyaq+wurFDgn6eVnmPMrBwBXbTGRrEdvPnzOP8rZzBcJMd/i6rJl9oUW+\
                +tGuw7hMhdDfLqjpobf9ZIkobD1EbPqJo5/9FiRLMlCSR/9SRia9P/Bt//d/O134IAm9IFQinIIzLlFy5SnaXVCoFSlRGJvZYCOfA5Qja+wMEajf//+2D\
                E1wAMBOVN/aaAIYaaqT23tWTSmYraIuPAPmNN/mGGYlj8KMYZGTnpenmj8jPGYLRAXGYu/8nPoTgWtUi/nj87zv/M/7CX88gDRjAKWldgkApotNGt00TH\
                lEBhgtn9uLSv0Sc/nEbz/sCFvWt+r2tnTjEQVQstf/++EzcEcl2HlR5rW2KaiypY0PDWjtJRtotUON/9Qf79ZxpKL79tf/AKkg/y3+TCn8gR/g+o+u+FA\
                2rlCxIFuBnSl5ARSsMIhIKgBAEL52VprweyeOvWzTPGNVYQ+1WqsGyoEoDJaaJ/zogAVQsDGBPf6i+m6y+X0y+HNTo+p09bai96RrYt/Evt/2f/+1DE7g\
                AMDNdP7MDv4ZQaqL2NNTT5L/TluQA0QA8chQIQCxNqBb9IlsL2JHHBIaZqa0ZZE+sPNducyryRlGFWlHAgV42o3so3msat73vgW9Qq0uYxUq63qstjDLD\
                a3h5EyUJHu/9MeSGmBYt6V/7bfX5FISuS6z3//u/q/IAErWAauA7aEvQSCKgERgiICJHpAYE+flE6iKTmo9jQV0l2t9Z1Ul70ctMocF7LFrn1N/rDL9tw\
                cSJrF3g5+VVzejARwfnMIxf/qQORUdv+oR+O//tQxOiACzTTS+09SyGcGim9l61kkf8l/IHv5H8hO9KgA3xAwFz+gD+oYWwEAfhCQ8IXjh15kZaMgnqGk\
                tNJZU/+15gbRQwNy0fV+tNQmgy97o1U0RljCGYI+AbRTWpK6lIKvJpJBwui31EgXGzMDIQKmhJ1cr//1/pwM41xfKxb0BYySpIMn0ncsmCD6SCC11pUvM\
                wWBqVez+v3qZiTJki2uzujeNK/QKyBDEAAdQ7ic7/prW4GQN5sYCzRfW/UO/UMZJ/8XBadhxEYM1ahO//7YMTlgAsEsUvsaadhj5govbeuXLE3936LgAI\
                XsARAIPgBRVdSdiD8rTnTrCbQkkbRfzbroi9IXvFgYABSuNvu46vdY52f/WEolmnQhllgBjW/5rhHug+VGJbRXgX9x73Iuxnj4e+5D/9yMCQLu/gpuVAz\
                qySJrF+AIaFRTN0AS606RmpDytr3wKsxg72x93F+txrjAaap2DdqOWmCIyuYHdDYjNNOqn2GRXp9qBnvYtp3HVa3rWEdkLGIMtdXeRAq9B+rXzMU30+iC\
                nxXFAEWRAyEqXgAFgxqCKCcwAZQMyU47zkaQkw+Ph/AWgqzubcM4Zgzy6mpaWaZy/hE/PNxbJ/n5f/7QMT/gAu8v0vtJPghaBapvae1LORY5OxfI07gIN\
                RxCz6GxJ6eNK5/6OM70hXIOwq6t0U6fqXGAEeQRQTKfAASKC4K6i51kGCRyeqsdGrhuLPk+qSA+uwjIIgJvWWyB5i5UujBcSIcHumAlj2O8XhCnXXX+qX\
                +4QLrffqHl9MBq753523BKlyR0uznwADgIyImQCQgsPNlkBIU0AVEId0JxPmBMZBfKhUqibe2l89fj9RytesW//tQxPQAC3C1T+ytsqFdGqk9pCrVrx31\
                z9ENPKVWwIz6HFxklLniiZkewxxvvnCYuHXfp+/0Kt4KvIOXX77gABElzy8os6ACdIdFvmZOMv1kVmICE4BwOuCcvit0IKBArHJH3z/Fc2lYDZV39NI2Q\
                FQn7pZ9qS/0+gUWVJg8yaOk76N6BCG9SPi+g9EiSl6mEoZemPTz7GV1SHLyoayw4Jh2PzZRXttv+GoQMVq4xTcFAIj7S89o6S5H0XQq1TAAghEQAFucAB\
                WohBEoQyKM+//7UMT4AAuY00/tPFFhYxIpPaelPGsIcAoE+6hxfebTVL/Lqi4IoF+JRBLM84k4lW0S15BUpmZ9FBTJMlrWRmjZmar9/W4Uk5zwssg1BNg\
                4gqTb1W4AM0kg/iCkCLePAkwhJ/klJ0WZ0JYJr9lkTj1EiaLQTTUOKoo4MlKolUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0DE+oAJqI9J7aVwYUuSKf2nlXxVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7MMT6gEiUkV3sMQ1hBxHqvZYd5FVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7IMT6gEmYjz/tMMxgtgal9PeYnVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=")
            }

            /* PacMan data */
            var pac = {
                p: {x:r,y:r},
                v: pacVelocity,               // velocity in px/s
                d: 'r',
                tol: .45 * r,       // tolerance spatial object extension
                mouth: [.2,.5,.8,.9,.8,.5,.2,0],
                phase: {'r': 0, 'u': 1.5*Math.PI , 'l': Math.PI, 'd': Math.PI/2},
                points: 0,
                steps: 1,
                show: 1
            }

            /* Ghost data */
            // https://en.wikipedia.org/wiki/Ghosts_(Pac-Man)
            var ghost = {
                // main ghost object
                back: {'l':'r','r':'l','u':'d','d':'u'},
                spawn: {x: fl(columns/2)*r, y: fl(rows/2+1)*r},
                v: ghostVelocity,
                cage: null,
                chase: 0,
                door: null,
                list: [],
                r: .01,
                vul: 0
            };

            /* Game data */
            var game = {
                up: 3,
                isOn: false,
                period: 15,
                coins: 0,
                coinPhase: 0,
                coinColor: ['#d6c78b', '#f2ed5a', '#cbcfc6', '#fcffcc']
            }

            // coin code
            function loadCoins (_grid) {
                for (i = 0; i < _grid.length; i++) {
                    for (j = 0; j < _grid[0].length; j++) {
                        if (!_grid[i][j].rigid && !isInCage(j*r,i*r)) {
                            if (u() < bigCoinRate) {
                                _grid[i][j].c = 2;
                            } else {
                                _grid[i][j].c = 1;
                            }
                            game.coins++
                        }
                    }
                }
                
            }
            async function eatCoin (x,y,_grid) {
                c = getCell(x+r/2,y+r/2,_grid);
                if (c.c) {
                    if (c.c > 1) {vulnerableTimeout(3+u()*7)}
                    c.c = 0;
                    game.coins--;
                    pac.points+=10;
                    for (i of [1,1]){
                        await sound.eat.play();
                    }
                    
                }
            }
            async function renderCoins (_grid, ctx) {
                var rad;
                const omega = 2*Math.PI*coinRotationRate;
                const dt = 1/maxFrameRate;
                const gcl = game.coinColor.length;
                while (1) {
                    await sl(1e3*dt)
                    ctx.clearRect(0, 0, width, height);
                    ctx.restore();
                    // ctx.save();
                    if(!game.isOn){continue}
                    for (i = 0; i < _grid.length; i++) {
                        for (j = 0; j < _grid[0].length; j++) {
                            const c = _grid[i][j];
                            if (c.c) {

                                if (c.c == 1) {
                                    rad = r/3/4;
                                } else {
                                    rad = r/3/2;
                                }
                                
                                sine = .5*(Math.sin(game.coinPhase)+1);
                                
                                ctx.beginPath();
                                ctx.ellipse(c.x+fl(r/2), c.y+fl(r/2), rad, rad, 0, 0, 2 * Math.PI);
                                ctx.fillStyle = game.coinColor[fl(sine*gcl)];
                                ctx.closePath();
                                ctx.fill();
                                
                            }
                        }
                    }
                    game.coinPhase = (game.coinPhase + omega * dt) % (2*Math.PI)
                } 
                
            }


            // game options
            async function newGame (_grid) {

                // fill grid with coins 
                loadCoins(_grid);

                // switch on the game and give pacman 5 seconds advantage
                await sl(1e3);
                game.isOn = 1;

                // wait until ghosts left the cage, and close it
                await sl(5e3);
                await releaseGhosts(_grid);

                soundLoop();

                // iteratively switch between chase and random, raise the velocity
                const catchLimit = (.75*r)**2
                while (game.up > 0) {
                    
                    await sl(30);
                    
                    for (g of ghost.list) {
                        
                        // check if pacman was caught
                        distance = distTo(g.p.x, g.p.y, pac.p.x, pac.p.y);
                        if (distance < catchLimit) {

                            if (ghost.vul) { 
                                g.p = {x:ghost.spawn.x+(u()-.5)*r, y:ghost.spawn.y+(u()-.5)*r};
                                game.isOn = 0;
                                await sl(1e3);
                                game.isOn = 1;
                                pac.points += 200;
                                await sl(5e3);
                                await releaseGhosts(_grid);
                                break
                            }


                            sound.die.play()
                            
                            game.isOn = 0;
                            await sl(3e3);
                            
                            pac.p = {x:r,y:r};
                            pac.d = 'r';
                            game.up--;

                            if (game.up == 0) {
                                pac.show = 0;
                                game.isOn = 1;
                                pac.p = {x:0,y:0};
                                ghostVelocity = .1;
                                break
                            }

                            for (g of ghost.list) {
                                g.p = {x:ghost.spawn.x+(u()-.5)*r, y:ghost.spawn.y+(u()-.5)*r}
                            }

                            for (let i = 0; i < 12; i++) {
                                await renderDynamicLayer(layers[3].ctx);
                                pac.show = !pac.show;
                                await sl(100)
                            }
                            
                            
                            game.isOn = 1;
                            await releaseGhosts(_grid);

                            break
                        }
                    }
                }

                // when the loop ends end the game
                //game.isOn = 0;

            }
             
            // grid code
            function getCell (x, y, grid) {
                return grid[fl(y/r)][fl(x/r)]
            }
            function fillCell (x, y, color, grid, ctx) {
                const c = getCell(x, y, grid);
                ctx.fillStyle = color;
                ctx.fillRect(c.x, c.y, r, r);
            }
            async function grid (columns, rows, resolution) {
                let     mat = [];
                const   c = resolution;
                for (let i=0; i<rows; i++) {
                    row = [];
                    for (let j=0; j<columns; j++) {
                        row.push({
                            x:j*c,
                            y:i*c,
                            rigid:0,
                            c:0,
                        })
                    } 
                    mat.push(row)
                } 
                return mat;
            }
            function incrementCoord (x, y, d, i) {
                [xn,yn]=[x,y]
                if (d == '') {
                    return [x,y]
                } else if (d == 'r') {
                    xn += i
                } else if (d == 'l') {
                    xn -= i
                } else if (d == 'u') {
                    yn -= i
                } else if (d == 'd') {
                    yn += i
                } return [xn,yn]
            }
            function isInCage (x, y) {
                const g = ghost;
                if (x<g.cage[0][0]*r||x>g.cage[0][1]*r||y<g.cage[1][0]*r||y>g.cage[1][1]*r) {
                    return false
                } 
                return true
            }
            function isRigid (x, y, grid) {
                return getCell(x, y, grid).rigid
            }
            async function isSpaceForWallBlock (x, y, grid) {            
                for (i of [-1,0,1]) {
                    for (j of [-1,0,1]) {
                        const [xn,yn] = [x+j*r,y+i*r];
                        if (isRigid(xn, yn, grid)) {
                            return false
                        }
                    }
                }
                return true
            }
            async function isSpaceToContinueWall (x, y, d, grid) {
                const [xn,yn] = incrementCoord(x,y,d,r);
                for (let i of [-1,0,1]) {
                    for (let j of [-1,0,1]) {
                        const [x_t,y_t] = [xn+j*r, yn+i*r];
                        if (!(y_t==y||x_t==x) && isRigid(x_t, y_t, grid)) {
                            return false
                        }
                    }
                }
                return true
            }
            async function setWallBlock (ctx, col, row, res, grid, color, rigid=1) {
                fillCell(col*res, row*res, color, grid, ctx);
                grid[row][col].rigid = rigid;
            }
            
            // maze code (with grid code dependency)
            async function canMoveInDir (x, y, d, grid, inc=1) {
                bias = 2;
                b1 = r-bias;
                b2 = bias;
                if (d == 'r') {
                    p1 = incrementCoord(x+r,y+b2,d,inc);
                    p2 = incrementCoord(x+r,y+b1,d,inc);
                } else if (d == 'd') {
                    p1 = incrementCoord(x+b2,y+r,d,inc);
                    p2 = incrementCoord(x+b1,y+r,d,inc);
                } else if (d == 'l') {
                    p1 = incrementCoord(x,y+b2,d,inc);
                    p2 = incrementCoord(x,y+b1,d,inc);
                } else if (d == 'u') {
                    p1 = incrementCoord(x+b2,y,d,inc);
                    p2 = incrementCoord(x+b1,y,d,inc);
                }
                return !isRigid(p1[0],p1[1],grid) && !isRigid(p2[0],p2[1],grid)
            }
            async function maze (grid, ctx, color, snakes=100, length=100, gaprate=0) {
                
                const   g = grid;
                const   res = g[0][1].x - g[0][0].x,
                        col = g[0].length,
                        row = g.length;

                ctx.fillStyle = color;
                
                // create outter frame
                for (let i=0; i<rows; i++) {
                    await setWallBlock(ctx, 0, i, res, g, color);
                    await setWallBlock(ctx, col-1, i, res, g, color)
                }
                for (let i=0; i<col; i++) {
                    await setWallBlock(ctx, i, 0, res, g, color);
                    await setWallBlock(ctx, i, row-1, res, g, color)
                }

                // place the cage
                dim = [];
                for (ind of [0,1]) {
                    d = [col, row][ind]
                    if (d % 2 == 0){
                        dim[ind] = 4
                    } else {
                        dim[ind] = 3
                    }
                }
                if (col>row && dim[1]>4){dim[1]--}
                
                start = [fl((col-dim[0])/2), fl((row-dim[1])/2)];
                await setWallBlock(ctx, start[0], start[1], res, g, color)
                for (let x = 0; x < dim[0]+1; x++) {
                    await setWallBlock(ctx, start[0]+x, start[1], res, g, color);
                    await setWallBlock(ctx, start[0]+x, start[1]+dim[1], res, g, color);
                    
                } 
                for (let y = 0; y < dim[1]; y++) {
                    await setWallBlock(ctx, start[0], start[1]+y, res, g, color);
                    await setWallBlock(ctx, start[0]+dim[0], start[1]+y, res, g, color);
                }
                ghost.cage = [[start[0],start[0]+dim[0]],[start[1],start[1]+dim[1]]];

                // install cage door
                ghost.door = {col: fl(start[0]+dim[0]/2), row: fl(start[1])} 
                await setWallBlock(ctx, ghost.door.col, ghost.door.row, res, g, retroBg);
                ctx.fillStyle = '#fff';
                ctx.fillRect(ghost.door.col*res, ghost.door.row*res+.4*res, res, .2*res);

                // fill internal space with snake method
                let p = {r:2,c:2},
                    br = 0;
                for (let i = 0; i < snakes; i++) {

                    // find new position, if search takes to long it ran out of space, then return
                    const lim = row*col*100;
                    for (let z = 0; z < lim; z++) {
                        // sample new point
                        const [c,r] = [fl(u()*(col-4))+2, fl(u()*(row-4))+2];
                        const [x,y] = [c*res, r*res];
                        if (!isInCage(x,y) && await isSpaceForWallBlock(x,y,g)) {
                            p.c = c;
                            p.r = r;
                            break
                        }
                        if (z == lim-1) {
                            br = 1;
                            break
                        }
                    } 
                    if (br) {break}
                    
                    // fill starting point
                    await setWallBlock(ctx, p.c, p.r, res, g, color)
                    
                    v = '', v_old = '', p_old = [];
                    count = 0;
                    for (let i=0; i<length; i++) {

                        // check directions
                        let d = [];
                        for (let direction of ['l', 'r', 'u', 'd']) {
                            if (await isSpaceToContinueWall(p.c*r, p.r*r, direction, g)) {
                                d.push(direction)
                            }
                        }
                        
                        // throw a die with geom. decreasing probability to keep the same direction
                        if (!(d.includes(v) && u() < 1/(1+count))) {
                            v = d[fl(u()*d.length)]
                            count = 0
                        }

                        // terminate snake if no direction is left
                        if (!d.length) {break}

                        // adjust position
                        [x_override, y_override] = incrementCoord(p.c*r, p.r*r, v, 1)
                        p.c = fl(x_override/r);
                        p.r = fl(y_override/r);

                        // increment the length
                        count++;

                        // set wall at former coord if direction hasn't chagned to leave sometimes a gap
                        if (v == v_old && u() < gaprate) {
                            await setWallBlock(ctx, p_old[0], p_old[1], res, g, retroBg, 0)
                        }
                        await setWallBlock(ctx, p.c, p.r, res, g, color);

                        v_old = v;
                        p_old = [p.c, p.r];
                    
                    }
                }
            
                // fill free space
                count = 0;
                for (let repeat = 0; repeat < 10; repeat++) {
                    for (let i = 3; i < row; i++) {
                        for (let j = 3; j < col; j++) {
                            const cell = g[i][j];
                            if (isInCage(cell.x, cell.y)) {continue}
                            if (!cell.rigid) {
                                for (let [a,b] of [
                                    [1,0],
                                    [1,1],
                                    [0,1],
                                    [-1,1],
                                    [-1,0],
                                    [-1,-1],
                                    [0,-1],
                                    [1,-1]
                                ]) {
                                    if (g[i+a][j+b].rigid) {
                                        count++
                                    }
                                    if (count > 1) {
                                        break
                                    }
                                }
                                if (count == 1) {
                                    await setWallBlock(ctx, j, i, res, g, color);
                                    
                                }
                                count = 0;
                            }
                        }
                    }
                }
                
                
            }
            function openDoor (grid,v=0) {
                grid[ghost.door.row][ghost.door.col].rigid = v
            }
            async function releaseGhosts (_grid) {
                openDoor(_grid);
                allLeft=0;
                while (!allLeft) {
                    allLeft=1;
                    for (g of ghost.list) {
                        if (isInCage(g.p.x,g.p.y)) {
                            allLeft=0
                        }
                    }
                    await sl(10);
                }
                openDoor(_grid, 1);
            }

            // pac-man code
            async function drawPacMan (ctx) {
                const rad = fl(r/2);
                const c = [pac.p.x+rad, pac.p.y+rad];
                const mouth_state = pac.mouth[fl(2*pac.steps*pac.mouth.length/r) % pac.mouth.length];
                ctx.save()
                ctx.beginPath();
                ctx.translate(c[0], c[1])
                ctx.rotate(pac.phase[pac.d])
                ctx.moveTo(0, 0)
                ctx.arc(0, 0, rad, mouth_state, 2*Math.PI-mouth_state);
                ctx.fillStyle = ctx.strokeStyle = '#d9e312';
                ctx.lineTo(0, 0);
                ctx.lineTo(rad*Math.cos(mouth_state),rad*Math.sin(mouth_state));
                ctx.closePath();
                ctx.fill();
                ctx.restore();

            }
            async function movePacMan (_grid) {
                [pac.p.x, pac.p.y]=incrementCoord(pac.p.x, pac.p.y, pac.d, increments);
                pac.steps++
                eatCoin(pac.p.x, pac.p.y, _grid)
            }
            async function movePacManContinuously (grid) {
                var dir = pac.d;
                while (dir == pac.d) {
                    await sl(increments/pac.v)
                    if (!game.isOn) {continue}
                    if (pac.reserve != '' && await canMoveInDir(pac.p.x, pac.p.y, pac.reserve, grid, increments)) {
                        pac.d = pac.reserve;
                        dir = pac.d;
                        pac.reserve = '';
                    } else if (!(await canMoveInDir(pac.p.x, pac.p.y, pac.d, grid, increments))) {
                        return
                    }
                    movePacMan (grid)
                    
                }
            }
            function bindKeyBoard (pacManObj, grid) {
                document.addEventListener('keydown', async(event) => {
                    if (game.isOn) {
                        var k = event.key, d;
                        if ( k == 'w' || k == 'ArrowUp' ) {d = 'u'} 
                        else if ( k == 'a' || k == 'ArrowLeft' ) {d = 'l'} 
                        else if ( k == 's' || k == 'ArrowDown' ) {d = 'd'} 
                        else if ( k == 'd' || k == 'ArrowRight' ) {d = 'r'}
                        if (d == pacManObj.d) {
                            //
                        } else if (await canMoveInDir(pacManObj.p.x, pacManObj.p.y, d, grid, increments) && pacManObj.d != d) {
                            pacManObj.d = d;
                            movePacManContinuously(grid);
                        } else if (pacManObj.d != d) {
                            pacManObj.reserve = d;
                        }
                    }
                    
                }, false);
                document.addEventListener('keyup', (event) => {
                    pacManObj.reserve = '';
                }, false);
            }
            
            // ghost code
            function initGhost (x, y, color) {
                ghost.list.push({
                    p: {
                        x: x,
                        y: y
                    },
                    c: color,
                    d: 'r',          // direction
                    s: 0,           // steps
                    r: 1          // randomness
                })
            }
            function distTo (x, y, x_t, y_t) {
                return ((x_t-x)**2+(y_t-y)**2)
            }
            async function drawGhost (_ghost, ctx) {
                const   rad = fl(resolution/2);
                const c = [_ghost.p.x+rad, _ghost.p.y+rad];
                ctx.beginPath();
                ctx.arc(c[0], c[1], rad, -Math.PI, 0);

                // draw all blue if ghosts are vulnerable
                if (ghost.vul) {
                    ctx.fillStyle = ctx.strokeStyle = '#0c1794';
                } else {
                    ctx.fillStyle = ctx.strokeStyle = _ghost.c;
                }
                
                ctx.fillRect(_ghost.p.x, _ghost.p.y+rad, resolution, fl(rad/2));
                for ([dx,dy] of [[2,2],[1.75,1.75],[1.5,2],[1.25,1.75],[1,2],[.75,1.75],[.5,2],[.25,1.75],[0,2],[0,1.75]]) {
                    ctx.lineTo(_ghost.p.x+dx*rad, _ghost.p.y+dy*rad);
                }
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                for (s of [-1,1]) {
                    ctx.arc(c[0]+s*fl(rad/2.3), c[1]-fl(rad/3.5), fl(rad/3), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();    
                }
                ctx.closePath();
                
                // eyes
                ctx.fillStyle = retroBg;
                ctx.beginPath();
                if (_ghost.d == 'u') {
                    bias = [0,-.2]
                } else if (_ghost.d == 'd') {
                    bias = [0,.2]
                } else if (_ghost.d == 'l') {
                    bias = [-.2,0]
                } else if (_ghost.d == 'r') {
                    bias = [.2,0]
                } else {
                    bias = [0,0]
                }
                ctx.arc(c[0]+fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.arc(c[0]-fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.fill();
                ctx.closePath();
            }
            async function sampleNewDir (pd) {
                return pd[fl(u()*pd.length)]
            }
            async function moveGhost (_ghost, grid) {
                
                var direction,t;
                const [x, y, g, G, I, backDir] = [_ghost.p.x, _ghost.p.y, _ghost, ghost, increments, ghost.back[_ghost.d]];
                
                // determine possible directions, 
                var pd = [], nd = []; 
                for (d of ['l','r','u','d']) {
                    if (await canMoveInDir(x, y, d, grid, I)) {
                        pd.push(d)
                        if (![g.d,backDir].includes(d)) {
                            nd.push(d)
                        }
                    }
                }

                // if there is only one option choose it
                if (pd.length < 2) {
                    direction = pd[0]
                }

                // run algorithm code if direction is not yet determined
                if (!direction) {

                    // select moving parameters depending on case
                    t = [pac.p.x, pac.p.y]
                    if (isInCage(x,y)) {
                        // cage movement code
                        t = [G.door[0], G.door[1]-1]
                    } else if (G.chase) {
                        // code for chase
                        [G.v, G.r] = [1.5*ghostVelocity, 0.02]
                    } else {
                        // random movement
                        [G.v, G.r] = [0.8*ghostVelocity, 0.05]
                    }

                    // perform algorithm
                    if (pd.includes(g.d)) {
                        direction = g.d;
                        if (nd.length > 0 && u() < G.r) {
                            direction = await sampleNewDir(nd);
                            g.s = 0
                        }
                    } else {
                        // try to decrease distance when in chase mode
                        // otherwise try to increase it when vulnerable
                        let cond, min;
                        if (G.vul) {min = 0}
                        else {min = 1e6}
                        for (d of pd) {
                            [xn, yn] = incrementCoord(x,y,d,I);
                            dist = distTo(xn, yn, t[0], t[1]);
                            if (G.vul) {
                                cond = dist > min
                            } else {
                                cond = dist < min
                            }
                            if (cond) {
                                min = dist;
                                direction = d
                            }
                        }
                        g.s = 0
                    }

                }

                // update direction if determined
                if (direction) { g.d = direction }

                // apply increment in chosen direction
                [g.p.x, g.p.y] = incrementCoord(g.p.x, g.p.y, g.d, I);
                g.s++

            }
            async function moveGhostContinously (_ghost, grid) {
                while (1) {
                    await sl(increments/ghost.v)
                    if (!game.isOn) {continue}
                    await moveGhost (_ghost, grid);
                }
            }
            async function vulnerableTimeout (t) {
                ghost.vul = 1;
                const v = ghostVelocity;
                ghostVelocity = 0.1;
                await sl(t*1e3);
                ghost.vul = 0;
                ghostVelocity = v;

            }
            async function soundLoop () {
                while (game.up>0) {
                    
                    // design sound
                    if (!game.isOn || ghost.vul || sound.mute) {
                        await sl(10);
                        continue
                    } else {
                        sound.siren.mozPreservesPitch = false;
                        sound.siren.playbackRate = 1 + 0.2*(3-game.up);
                        await sound.siren.play();
                        await sl(1);
                    }
                }
            }
            
            // render code
            async function renderDynamicLayer (dynCtx) {
                dynCtx.clearRect(0, 0, width, height);
                if (pac.show) {
                    await drawPacMan(dynCtx);
                }
                for (g of ghost.list) {
                    await drawGhost(g, dynCtx)
                }
            }
            async function renderEngine (dynCtx, interCtx) {
                
                // initialize asynchronous coin rendering 
                // on interactive layer
                renderCoins(_grid, interCtx);

                // start rendering content on dynamic layer
                while (1) {
                    try {
                        await renderDynamicLayer(dynCtx, interCtx)
                    } catch (error) {
                        console.error(error)
                    } finally {
                        await sl(1e3/maxFrameRate)
                    }
                }
            }

            /* -- instantiate -- */
            const staticCtx = layers[1].ctx;
            const interCtx = layers[2].ctx;
            const dynamicCtx = layers[3].ctx;

            // load all ghosts to cage
            for (c of ['red', 'cyan', 'orange', 'pink']) {
                initGhost(ghost.spawn.x+(u()-.5)*r, ghost.spawn.y+(u()-.5)*r, c)
            }

            // instantiate grid
            const _grid = await grid(columns, rows, r);

            // initialize maze on background layer
            await maze(_grid, staticCtx, wallColor, snakes=mazeWallNumber, length=mazeWallLength, gaprate=0.1);
            
            for (gs of ghost.list) {
                moveGhostContinously(gs,_grid)
            }

            // bind keys to pacman
            bindKeyBoard(pac, _grid);

            // ignite asynchronous render engine
            renderEngine(dynamicCtx, interCtx);
            
            // start new game
            newGame(_grid);
            
            
        })();
        

    </script>

</body>

</html>