<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>
        (async() => {

            // graphics
            const   height = 680,
                    width = 960,
                    mazeWallGapRate = 0.3,
                    mazeWallLength = 100,
                    mazeWallNumber = 100,
                    resolution = 40,
                    wallColor = '#1b0f9d',
                    retroBg = '#121212',
                    maxFrameRate = 60,
                    increments = 2,
                    pacVelocity = .5; // px/ms

            // general
            function u(){return Math.random()}
            function fl(x){return Math.floor(x)}
            function sl(t){return new Promise(r=>setTimeout(r,t))}

            // format body
            const body = document.body;
            body.style.margin = 0;
            body.style.overflow = 'hidden';

            //  canvas
            // create layers
            // Layer 1: Background Layer
            // Layer 2: Dynamic Layer
            const   r = resolution;
            const   columns = fl(width/r);
            const   rows = fl(height/r);
            var layers = {};
            for (i of [1,2]) {
                const el = document.createElement('canvas');
                const obj = {
                    canvas: el,
                    ctx: el.getContext('2d'),
                }
                await sl(.1)
                obj.ctx.canvas.width = width;
                obj.ctx.canvas.height = height;
                if (i == 1) {
                    obj.ctx.fillStyle = retroBg;
                    obj.ctx.fillRect(0, 0, width, height);
                } else if (i == 2) {
                    el.style.position = 'absolute';
                    el.style.top = '0';
                    el.style.left = '0';
                }
                el.style.width = columns * r;
                el.style.height = rows * r;
                el.style.zIndex = `${i}`;
                body.prepend(el);
                layers[i] = obj;
            }
            function canvasOffset (canvas) {
                return [canvas.offsetLeft + canvas.clientLeft, canvas.offsetTop + canvas.clientTop]
            }
            
            /* PacMan data */
            var pac = {
                p: {x:r,y:r},
                v: pacVelocity,               // velocity in px/s
                d: 'r',
                tol: .45 * r,       // tolerance spatial object extension
                mouth: [.2,.5,.8,.9,.8,.5,.2,0],
                phase: {'r': 0, 'u': 1.5*Math.PI , 'l': Math.PI, 'd': Math.PI/2},
                coins: 0,
                steps: 1,
                sound: new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=")
            }

            /* Ghost data */
            // https://en.wikipedia.org/wiki/Ghosts_(Pac-Man)
            var ghost = {
                // main ghost object
                back: {'l':'r','r':'l','u':'d','d':'u'},
                spawn: {x: fl(columns/2)*r, y: fl(rows/2+1)*r},
                v: .3,
                cage: null,
                chase: 0,
                door: null,
                list: [],
                r: .01
            };

            // grid code
            function getCell (x, y, grid) {
                //console.log(x,y,fl(y/r),fl(x/r), grid);
                return grid[fl(y/r)][fl(x/r)]
            }
            function fillCell (x, y, color, grid, ctx) {
                const c = getCell(x, y, grid);
                ctx.fillStyle = color;
                ctx.fillRect(c.x, c.y, r, r);
            }
            async function grid (columns, rows, resolution) {
                let     mat = [];
                const   c = resolution;
                for (let i=0; i<rows; i++) {
                    row = [];
                    for (let j=0; j<columns; j++) {
                        row.push({
                            x:j*c,
                            y:i*c,
                            rigid:0
                        })
                    } 
                    mat.push(row)
                } 
                return mat;
            }
            function incrementCoord (x, y, d, i) {
                [xn,yn]=[x,y]
                if (d == '') {
                    return [x,y]
                } else if (d == 'r') {
                    xn += i
                } else if (d == 'l') {
                    xn -= i
                } else if (d == 'u') {
                    yn -= i
                } else if (d == 'd') {
                    yn += i
                } return [xn,yn]
            }
            function isInCage (x, y) {
                const g = ghost;
                if (x<g.cage[0][0]*r||x>g.cage[0][1]*r||y<g.cage[1][0]*r||y>g.cage[1][1]*r) {
                    return false
                } 
                return true
            }
            function isRigid (x, y, grid) {
                return getCell(x, y, grid).rigid
            }
            async function isSpaceForWallBlock (x, y, grid) {            
                for (i of [-1,0,1]) {
                    for (j of [-1,0,1]) {
                        const [xn,yn] = [x+j*r,y+i*r];
                        if (isRigid(xn, yn, grid)) {
                            return false
                        }
                        //fillCell(xn, yn, 'yellow', grid, layers[1].ctx)
                    }
                }
                return true
            }
            async function isSpaceToContinueWall (x, y, d, grid) {
                const [xn,yn] = incrementCoord(x,y,d,r);
                for (let i of [-1,0,1]) {
                    for (let j of [-1,0,1]) {
                        const [x_t,y_t] = [xn+j*r, yn+i*r];
                        if (!(y_t==y||x_t==x) && isRigid(x_t, y_t, grid)) {
                            return false
                        }
                        //testing
                        //fillCell(xn, yn, 'yellow', grid, layers[1].ctx)
                    }
                }
                return true
            }
            async function setWallBlock (ctx, col, row, res, grid, color, rigid=1) {
                fillCell(col*res, row*res, color, grid, ctx);
                grid[row][col].rigid = rigid;
            }
            
            // maze code (with grid code dependency)
            async function canMoveInDir (x, y, d, grid, inc=1) {
                //var [xn,yn] = incrementCoord(x,y,d,inc);
                bias = 2;
                b1 = r-bias;
                b2 = bias;
                if (d == 'r') {
                    p1 = incrementCoord(x+r,y+b2,d,inc);
                    p2 = incrementCoord(x+r,y+b1,d,inc);
                } else if (d == 'd') {
                    p1 = incrementCoord(x+b2,y+r,d,inc);
                    p2 = incrementCoord(x+b1,y+r,d,inc);
                } else if (d == 'l') {
                    p1 = incrementCoord(x,y+b2,d,inc);
                    p2 = incrementCoord(x,y+b1,d,inc);
                } else if (d == 'u') {
                    p1 = incrementCoord(x+b2,y,d,inc);
                    p2 = incrementCoord(x+b1,y,d,inc);
                }
                //console.log('rigid',isRigid(xn,yn,grid))
                return !isRigid(p1[0],p1[1],grid) && !isRigid(p2[0],p2[1],grid)
            }
            async function maze (grid, ctx, color, snakes=100, length=100, gaprate=0) {
                
                const   g = grid;
                const   res = g[0][1].x - g[0][0].x,
                        col = g[0].length,
                        row = g.length;

                ctx.fillStyle = color;
                
                // create outter frame
                for (let i=0; i<rows; i++) {
                    await setWallBlock(ctx, 0, i, res, g, color);
                    await setWallBlock(ctx, col-1, i, res, g, color)
                }
                for (let i=0; i<col; i++) {
                    await setWallBlock(ctx, i, 0, res, g, color);
                    await setWallBlock(ctx, i, row-1, res, g, color)
                }

                // place the cage
                dim = [];
                for (ind of [0,1]) {
                    d = [col, row][ind]
                    if (d % 2 == 0){
                        dim[ind] = 4
                    } else {
                        dim[ind] = 3
                    }
                }
                if (col>row && dim[1]>4){dim[1]--}
                
                start = [fl((col-dim[0])/2), fl((row-dim[1])/2)];
                await setWallBlock(ctx, start[0], start[1], res, g, color)
                for (let x = 0; x < dim[0]+1; x++) {
                    await setWallBlock(ctx, start[0]+x, start[1], res, g, color);
                    await setWallBlock(ctx, start[0]+x, start[1]+dim[1], res, g, color);
                    
                } 
                for (let y = 0; y < dim[1]; y++) {
                    await setWallBlock(ctx, start[0], start[1]+y, res, g, color);
                    await setWallBlock(ctx, start[0]+dim[0], start[1]+y, res, g, color);
                }
                ghost.cage = [[start[0],start[0]+dim[0]],[start[1],start[1]+dim[1]]];

                // install cage door
                ghost.door = {col: fl(start[0]+dim[0]/2), row: fl(start[1])} 
                await setWallBlock(ctx, ghost.door.col, ghost.door.row, res, g, retroBg);
                ctx.fillStyle = '#fff';
                ctx.fillRect(ghost.door.col*res, ghost.door.row*res+.4*res, res, .2*res);

                // fill internal space with snake method
                let p = {r:2,c:2},
                    br = 0;
                for (let i = 0; i < snakes; i++) {

                    // find new position, if search takes to long it ran out of space, then return
                    const lim = row*col*100;
                    for (let z = 0; z < lim; z++) {
                        // sample new point
                        const [c,r] = [fl(u()*(col-4))+2, fl(u()*(row-4))+2];
                        const [x,y] = [c*res, r*res];
                        if (!isInCage(x,y) && await isSpaceForWallBlock(x,y,g)) {
                            p.c = c;
                            p.r = r;
                            break
                        }
                        if (z == lim-1) {
                            br = 1;
                            break
                        }
                    } 
                    if (br) {break}
                    
                    // fill starting point
                    await setWallBlock(ctx, p.c, p.r, res, g, color)
                    
                    v = '', v_old = '', p_old = [];
                    count = 0;
                    for (let i=0; i<length; i++) {

                        // check directions
                        let d = [];
                        for (let direction of ['l', 'r', 'u', 'd']) {
                            if (await isSpaceToContinueWall(p.c*r, p.r*r, direction, g)) {
                                d.push(direction)
                            }
                        }
                        
                        // throw a die with geom. decreasing probability to keep the same direction
                        if (!(d.includes(v) && u() < 1/(1+count))) {
                            v = d[fl(u()*d.length)]
                            count = 0
                        }

                        // terminate snake if no direction is left
                        if (!d.length) {break}

                        // adjust position
                        [x_override, y_override] = incrementCoord(p.c*r, p.r*r, v, 1)
                        p.c = fl(x_override/r);
                        p.r = fl(y_override/r);

                        // increment the length
                        count++;

                        // set wall at former coord if direction hasn't chagned to leave sometimes a gap
                        if (v == v_old && u() < gaprate) {
                            await setWallBlock(ctx, p_old[0], p_old[1], res, g, retroBg, 0)
                        }
                        await setWallBlock(ctx, p.c, p.r, res, g, color);

                        v_old = v;
                        p_old = [p.c, p.r];
                    
                    }
                }
            
                // fill free space
                count = 0;
                for (let repeat = 0; repeat < 10; repeat++) {
                    for (let i = 3; i < row; i++) {
                        for (let j = 3; j < col; j++) {
                            const cell = g[i][j];
                            if (isInCage(cell.x, cell.y)) {continue}
                            if (!cell.rigid) {
                                for (let [a,b] of [
                                    [1,0],
                                    [1,1],
                                    [0,1],
                                    [-1,1],
                                    [-1,0],
                                    [-1,-1],
                                    [0,-1],
                                    [1,-1]
                                ]) {
                                    if (g[i+a][j+b].rigid) {
                                        count++
                                    }
                                    if (count > 1) {
                                        break
                                    }
                                }
                                if (count == 1) {
                                    await setWallBlock(ctx, j, i, res, g, color);
                                    
                                }
                                count = 0;
                            }
                        }
                    }
                }
                
                
            }
            function openDoor (grid) {
                grid[ghost.door.row][ghost.door.col].rigid = 0
            }

            // pac-man code
            async function drawPacMan (ctx) {
                const rad = fl(r/2);
                const c = [pac.p.x+rad, pac.p.y+rad];
                const mouth_state = pac.mouth[fl(2*pac.steps*pac.mouth.length/r) % pac.mouth.length];
                ctx.save()
                ctx.beginPath();
                ctx.translate(c[0], c[1])
                ctx.rotate(pac.phase[pac.d])
                ctx.moveTo(0, 0)
                ctx.arc(0, 0, rad, mouth_state, 2*Math.PI-mouth_state);
                ctx.fillStyle = ctx.strokeStyle = '#d9e312';
                ctx.lineTo(0, 0);
                ctx.lineTo(rad*Math.cos(mouth_state),rad*Math.sin(mouth_state));
                ctx.closePath();
                ctx.fill();
                ctx.restore();

            }
            async function movePacMan () {
                [pac.p.x, pac.p.y]=incrementCoord(pac.p.x, pac.p.y, pac.d, increments);
                pac.sound.play();
                pac.steps++
            }
            async function movePacManContinuously (grid) {
                var dir = pac.d;
                while (dir == pac.d) {
                    if (pac.reserve != '' && await canMoveInDir(pac.p.x, pac.p.y, pac.reserve, grid, increments)) {
                        pac.d = pac.reserve;
                        dir = pac.d;
                        pac.reserve = '';
                    } else if (!(await canMoveInDir(pac.p.x, pac.p.y, pac.d, grid, increments))) {
                        return
                    }
                    movePacMan ()
                    await sl(increments/pac.v)
                }
            }
            function bindKeyBoard (pacManObj, grid) {
                document.addEventListener('keydown', async(event) => {
                    var k = event.key, d;
                    if ( k == 'w' || k == 'ArrowUp' ) {d = 'u'} 
                    else if ( k == 'a' || k == 'ArrowLeft' ) {d = 'l'} 
                    else if ( k == 's' || k == 'ArrowDown' ) {d = 'd'} 
                    else if ( k == 'd' || k == 'ArrowRight' ) {d = 'r'}
                    if (d == pacManObj.d) {
                        //
                    } else if (await canMoveInDir(pacManObj.p.x, pacManObj.p.y, d, grid, increments) && pacManObj.d != d) {
                        pacManObj.d = d;
                        movePacManContinuously(grid);
                    } else if (pacManObj.d != d) {
                        pacManObj.reserve = d;
                    }
                    
                }, false);
                document.addEventListener('keyup', (event) => {
                    pacManObj.reserve = '';
                }, false);
            }
            
            // ghost code
            function initGhost (x, y, color) {
                ghost.list.push({
                    p: {
                        x: x,
                        y: y
                    },
                    c: color,
                    d: 'r',          // direction
                    s: 0,           // steps
                    r: 1          // randomness
                })
            }
            function distToPacMan (x, y, x_t, y_t) {
                return ((x_t-x)**2+(y_t-y)**2)
            }
            async function drawGhost (_ghost, ctx) {
                const   rad = fl(resolution/2);
                const c = [_ghost.p.x+rad, _ghost.p.y+rad];
                ctx.beginPath();
                ctx.arc(c[0], c[1], rad, -Math.PI, 0);
                ctx.fillStyle = ctx.strokeStyle = _ghost.c;
                ctx.fillRect(_ghost.p.x, _ghost.p.y+rad, resolution, fl(rad/2));
                for ([dx,dy] of [[2,2],[1.75,1.75],[1.5,2],[1.25,1.75],[1,2],[.75,1.75],[.5,2],[.25,1.75],[0,2],[0,1.75]]) {
                    ctx.lineTo(_ghost.p.x+dx*rad, _ghost.p.y+dy*rad);
                }
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                for (s of [-1,1]) {
                    ctx.arc(c[0]+s*fl(rad/2.3), c[1]-fl(rad/3.5), fl(rad/3), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();    
                }
                ctx.closePath();
                
                // eyes
                ctx.fillStyle = retroBg;
                ctx.beginPath();
                if (_ghost.d == 'u') {
                    bias = [0,-.2]
                } else if (_ghost.d == 'd') {
                    bias = [0,.2]
                } else if (_ghost.d == 'l') {
                    bias = [-.2,0]
                } else if (_ghost.d == 'r') {
                    bias = [.2,0]
                } else {
                    bias = [0,0]
                }
                ctx.arc(c[0]+fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.arc(c[0]-fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.fill();
                ctx.closePath();
            }
            async function sampleNewDir (pd) {
                return pd[fl(u()*pd.length)]
            }
            async function moveGhost (_ghost, grid) {
                
                var direction,t;
                const [x, y, g, G, I, backDir] = [_ghost.p.x, _ghost.p.y, _ghost, ghost, increments, ghost.back[_ghost.d]];
                
                // determine possible directions, 
                var pd = [], nd = []; 
                for (d of ['l','r','u','d']) {
                    if (await canMoveInDir(x, y, d, grid, I)) {
                        pd.push(d)
                        if (![g.d,backDir].includes(d)) {
                            nd.push(d)
                        }
                    }
                }

                // if there is only one option choose it
                if (pd.length < 2) {
                    direction = pd[0]
                }

                // run algorithm code if direction is not yet determined
                if (!direction) {

                    // select moving parameters depending on case
                    t = [pac.p.x, pac.p.y]
                    if (isInCage(x,y)) {
                        // cage movement code
                        t = [G.door[0], G.door[1]-1]
                    } else if (G.chase) {
                        // code for chase
                        [G.v, G.r] = [.5, 0.02]
                    } else {
                        // random movement
                        [G.v, G.r] = [.3, 0.05]
                    }

                    // perform algorithm
                    if (pd.includes(g.d)) {
                        direction = g.d;
                        if (nd.length > 0 && u() < G.r) {
                            direction = await sampleNewDir(nd);
                            g.s = 0
                        }
                    } else {
                        min = 1e6;
                        for (d of pd) {
                            [xn, yn] = incrementCoord(x,y,d,I);
                            dist = distToPacMan(xn, yn, t[0], t[1]);
                            if (dist < min) {
                                min = dist;
                                direction = d
                            }
                        }
                        g.s = 0
                    }

                }

                // update direction if determined
                if (direction) { g.d = direction }

                // apply increment in chosen direction
                [g.p.x, g.p.y] = incrementCoord(g.p.x, g.p.y, g.d, I);
                g.s++

            }
            async function moveGhostContinously (_ghost, grid) {
                while (1) {
                    await moveGhost (_ghost, grid);
                    await sl(increments/ghost.v)
                }
            }
            
            // render code
            async function renderEngine (ctx) {
                while (1) {
                    try {
                        ctx.clearRect(0, 0, width, height);
                        await drawPacMan(ctx);
                        for (g of ghost.list) {
                            await drawGhost(g, ctx)
                        }
                    } catch (error) {
                        console.error(error)
                    } finally {
                        await sl(1000/maxFrameRate)
                    }
                }
            }

            /* -- instantiate -- */
            const staticCtx = layers[1].ctx;
            const dynamicCtx = layers[2].ctx;

            // load all ghosts to cage
            for (c of ['red', 'cyan', 'orange', 'pink']) {
                initGhost(ghost.spawn.x+(u()-.5)*r, ghost.spawn.y+(u()-.5)*r, c)
            }

            // instantiate grid
            const _grid = await grid(columns, rows, r);

            // initialize maze on background layer
            await maze(_grid, staticCtx, wallColor, snakes=mazeWallNumber, length=mazeWallLength, gaprate=0.1);
            openDoor(_grid)
            for (gs of ghost.list) {
                moveGhostContinously(gs,_grid)
            }

            // bind keys to pacman
            bindKeyBoard(pac, _grid)

            // ignite asynchronous render engine
            renderEngine(dynamicCtx)
            

            await sleep (20*1e3)

            G.chase = 1
            
        })();
        

    </script>

</body>

</html>