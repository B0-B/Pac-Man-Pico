<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body style="background:#454545">

    <script>
        (async() => {

            // graphics
            const   height = 640,
                    width = 960,
                    mazeWallGapRate = 0.3,
                    mazeWallLength = 100,
                    mazeWallNumber = 100,
                    resolution = 40,
                    wallColor = '#1b0f9d',
                    retroBg = '#121212',
                    maxFrameRate = 60,
                    coinRotationRate = 1,
                    increments = 2,
                    pacVelocity = .5, // px/ms
                    bigCoinRate = 0.03;
            var     ghostVelocity = .3;

            // general
            function u(){return Math.random()}
            function fl(x){return Math.floor(x)}
            function sl(t){return new Promise(r=>setTimeout(r,t))}
            function canvasOffset (canvas) {return [canvas.offsetLeft + canvas.clientLeft, canvas.offsetTop + canvas.clientTop]}
            function au(b64){return new Audio("data:audio/mpeg;base64,"+b64)}
            function cl(ctx){ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);}

            /* Sound data */
            var sound = {
                mute: 0,
                eat: au("//sQxAAABJBhDBRhgAihkuYDMFABAAAABCHJkyaEREGECEO7//URET9Hdz/dwAQgj/zDw8PfgAAAj6XeCAoBg/t3q710a/Pb8bSkP1qrKgEX\
                5bA7xf8yHSNA4fyb3J4uH8iFDXACPGD/+xLEAwAFaEFiGPQAAKcGbbOYIAAuKh+c6ychcb+WqmRbujyFf38eMblRI4vrEsPALcrCYZHfz6RjYigUCQgBA\
                V4g2C4G7h0psfVX0q1So6h8VMLvQv9hBK5oovat55PoVanp1DR0Ewv/+xDEAoHFAKVmA7BDwJmJrRRmGILFsZeIq3BLZ2zuQwayeViYAoDwNsfRKdv+Xb\
                r+N8Fxv8+Jr6IhxoPAKjoEAxZiAxcIKUebsLe2UyFds7HreLqNOu/t1Nd69yJ5FXKQCSAEEATcFv/7EsQEgEXAL12ApMDAjZka3DALQSdCVDI0KQCAQkr\
                ZOAStNIyJQVFAakToK1A0Co0JHv//1hI9KiIQgAElL/nDlR1/11+GtgMYy1WOXgVkcT//9Cq36f6V9A5QEUoABA/gcD/8qGVv+//7EMQFg8PUysUhALpI\
                AAA0gAAABIYVKyGcKYz4USZ7I////RxEAjgVoE8AA+D7+CGD/+D4fygIAg7lAQy7/UGT+XBAEC4PqvFAAZJV4G2JAfyF4GHggbcP4HBVg3F+GCBQQNwf4\
                3gL//sSxB+CAAABpAAAACB4gBRagiAADBu//BuAMDhgsMFjd//FBhgsUBjc//xvDexuRv///igxv0CAQigUGgUCgVBAAAALjzUKfMwbrAKVI5cJljGInA\
                IAAiGwIOMRiCaBgWwfOeZhdxrE//sQxDoACDzvGhlKAAEPFi13GFAAOrvZLZfHyC7ojdkZeryLjvylmWIQAAAQBPTVMJNT2h2JqynN6Wf5xPVV4CPyk0Q\
                zeP4LR/Rk/tpc4KEOTeADicEm16OskDtRNVdJBsEziDIYBsb/+xLEIIAEyG9rnMEAAJOGLZQBJAAZAEDQSr//V10VqveegECo71X8ugVgRuuDiZv8T4ts\
                e/uQxBRZJUW/O9//6unQBQADIhlQmQnABCbVgKoBOAlhhVgqgJ5VM9DX/9RVIdaHapgClLX/+xDEJIBEQDFpAL2AgIkGLOSUjBhGuoZxNLmXkqMqCg0OQ\
                wqCQNgsa+gFArgqCTeM6RYKhoqgOyX/+S/KwUMCDo5fZ//sYoJAcNGgq3+Kt/itTEFNRTMuMTAwVVVVVVVVVVVVVVVVVf/7EsQrggRkQy4ggGBAdhAVWA\
                GJqFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ=\
                ="),
                die: au("SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU5LjI3LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAA\
                AAASW5mbwAAAA8AAAAtAAATFAAODhQUGRkfHyQkJCoqLy81NTo6QEBARUVLS1BQVlZWW1thYWZmbGxxcXF3d3x8goKHh4eMjJKSl5ednaKioqiora2zs7\
                i4uL6+w8PJyc7O1NTU2dnf3+Tk6urq7+/19fr6//8AAAAATGF2YzU5LjM3AAAAAAAAAAAAAAAAJARAAAAAAAAAExRnXkZWAAAAAAD/+xDEAAADwCrfNIM\
                AILuYpwMWcADsAAgDAB3d3flxQypDsFYC4N2BwsmD4Pp///8uD+n7oEAt/oSM9OwCDnUgncmeAAGwX+eehg4JAQDvzG6MNBc3/9xOE6kP/88Cg4LCaLRF\
                07r/QP/7EsQDAAVYl2QY9oAApwmss57QAOhnE3YJY5Ule2kenS0Zuo4OQZbA8EszZqbo1Gn9Grbq/rVVzypYCgKgSUATbtbL1WjcV0GauePhHRtoooz7p\
                KmB8LIsbrUe1hX+/D3MftoVhsGMXv/7EMQCgAUEg3WAIKHwqwluPACkBKgC32MCo6Gfw23qqhwlS4WrS5RyGZGUquj//pxQ8YnL/TN3hEjLk8sK1IEAE4\
                FgciQUs3YLnBPCN9grnuEEZx/++aWVDXKkvyP//wyJkRqLjrDL//sSxAKARTh/f6Ag4bCeiG7wBKA2WSQBJFFDMtxp2Gb3jFRmpeKfNPCE+t4ROYuqZ3/\
                UbEGXfv/0IGZ8OjN6SQyBUO4hMNKEbGkKJmWX1KBERzr+Cyz1jwVdQ3kJ3/u5LQoajQaB2c4H//sQxAOABVR3Z4aA2ACpD250BJxaUxiEIgaJzMMJi5sb\
                5RQ6hUHMOc/yk79SkW7uwYEIjJ/U3+lQELgbZcDYQATEAGj16oRGhJJXlGspEKBMLn8SObHjWr/+rR4W13+Iyf/TCGF2N2b/+xLEAoBFLFOD4DEhcKKP7\
                vQUnLY7QwAAGhJslQ5SPQbAD76UN6ybedtsFQ23/qQfMMfOk3/xGGHiwSG2lxo9xnX5Iux0J8CF/fFB/NplQIHaPENeo7M99Tv9Budi3oX/6xsLTpC9EC\
                D/+xDEA4AFUFl7oCVhsKiJ7PQWJGgBclYpvXbVJfo+EQQl7j/9biXfLLhRcmfBBB6GB0Q/xCQ//sGwTAjFiCQAHWPpQCGlGayyTQN/P88llx/iCxkN/Ms\
                iG34kOf5UYG8h/OoaBMCYSf/7EsQCgEVAjWmlANognpIs9AeoaEAIAc6RwK41MIlxeDcfVy0Xjjm6wFhqTmUjMaH/OLf/E2Q3/+kCgVBsB0q+cjJS+daz\
                VtHytcw96kveQiJAgObmmiw3sQkn/9X+iFC1ApUZsRjiAP/7EMQDgASQk4GhDKXwi4/t9HALAAHhGgwqqcJwR70vbShBCIDN8YNZX7t/9XkM/zjusfD4T\
                EBBgYAd42AxCSuTgeRLDZT0FD9IPyPb/b/oJI///kmqFohEIH95X9Alyx5ZMrwhvHB6//sSxAkABAA7YIeJ7ICPBvB0Awg2inoxmQms2DuU/4RDpG8fHV\
                ekqBBgAeTyZ+INBIEHalJqDejCnQjhYrf+aI0/7ifU5LoYmw6l8QwGx0qGphSeHvINEcw8exAh9pgsO9qfBvq//5Ht//sQxBEABFhxe4OAWDCRh+00BaQ\
                MsHD4H4TiIBAFPYFYk3WOIwhv3073lJh3I5U3nYih0n8Lp///99UYTBbOOtsMAdKhjIFVHbqUZKiVgcDd52fp/f/wrbft//LMBEghkYEIDoOBgjz/+xLE\
                FoAEaG+DoqBMsI2HrGTRPVDZOTgbICyrH4M5CbM2/qBZ9v8oDUp//u9YuhQYDEJ7AgGaEA241AMKaxJ85w+/jJBEf4dAs/5bX//c75NJQJIHMZkVqDGY8\
                BQT+ghPRhabP8SotOb/+xDEHQBEcEl1gBTB8IyObjx2COxsPETWQOI0s///wh9NHo4PwSgAIAHKBiMrOF2gG79BuJPsryDBARu66EVigh/kX///rGg1FY\
                LgAxW0QWikWG2aKlb5G2SOboEoLJhjyARfy7H////7EsQjAESYQ22gLMFgjA7s9AeoLOVdGp1VyXlCB4cYJ8b2kRUmxr9wjYzjQUUfiROt3+4p3egOf9P\
                mCwEMWNCmmWQrSozazTrTBrhS5fbk12qT/0BZFKPzuW1ryCoCiQWIKxEAAeMAwv/7EMQpAARcQ32AJKHwjQ+rQRAXAMCTNFXDIaEXy+kZ401A0LmewC89\
                FAN+3/zGD30BlggYFoIpiuj2pslBfVSbz30JgACOAUDTQCFgah5/9RlQcM0enw3LSCBgAfnkpBjeDiGEAX9b//sSxC8AROyBZ6KsRcCNB6xkB5xgzwr12\
                gGRiUoymJh5vEf//xIFjGBT+r34ZFAgGwNQAAAH9HLwwR89YXhBx4vHzlEx/XPHOeJ2UxYe88WPX//h3Vft+3QqGT5WxlhKTABT4HgU2Bgp//sQxDOABX\
                h5gaMksjCtjiw08wpI1wKfhtxABW871CXN+qIUX+FzEl3eUArv+v6qOIxAYC4C6WCgBqFYPkfRJWD45ddZQXmx0nwKiNtgm7lEqzIwRv7RZoOCd3/r1/L\
                VFAolASZaFAH/+xLEMQAFeE17oCEgcLaNrTRViHq63J6t+rHISRX1tuN/mBQDU7zrnalDyfw8G7fS6r2o/HjCQTJPPJAy+sTbBRTtZy4iW2CAjzlbov/6\
                MMKhob9Tf4c9GhUcyv0Sf8gFzzolVh9qIIX/+xDELgAFFD9loD1hQI6Mr7AElDbyKQqeW5YZLTxozZv/b0BEUKnPT/DPoDAZjxwJcIAWAC8aFZ9Vk6eE4\
                AB484/qEQdsRG4Nv/Cpqv/+n+UVHFw/ImrgIAHjwEPauwcF0mNs9WgpDf/7EsQxAAS4YXmAPOEwlgduvASULL6jbqVT1/5pFQY+r/d6TDPB9wgNG0AMcd\
                pOACNbmoP2+LHkLxmYG/YRqb/0MLGwkrUz9/+tMMMLlDA9LiKqP1xKPkW0nSbqMAPnvNQnfSY9v/qPSv/7EMQ1AASIZW+gJOGgmg0sZBWIeD0f/ru+odP\
                1/PWBrQRhYatRCsTgaj6oqTR27VDI8OEkXoQ/3J0b//KN/oUYikaBSAgAAbtMQ8KM1zEOp+au6Jp1GQxhanDXSHu9WkzbaB30D06P//sSxDkARJBpZSA9\
                QQCUDnA0VJy+1qUMBADRUEQnJPHghAuehehV/G4s+NjPK3/BggMvZ//7lfWXwWEYqFaiVBtybbrNkVpKNQKyOVrrJ36z39pkCNYtzvSjU1VZ6XdIqEYDY\
                G7lyMTa//sQxD4ABKR3aaaAWCCQjrB0cAsGGUMAfbZx8dega5FL+ZU6l/frURkf//6mKpitFGE4kCQB2mpkUO9F9XkhDvQ95xkq3r6He//pGDbP/9vvDx\
                jhgIAYBHIHItazooxalVn9/X50eg//+xLEQoBE8HtYCQDYAIqN7rAUiDYWF7rMPJr/EIdt/o//3xxYL4LAySABu0FbDoIxs0xUKIL6hIFgXxLyP/+c7gY\
                h+v4h2+uRkNEFIrYu5gAZHNdNnQQL4Lk8lkkj0v/8xOAVJ/076Mn/+xDERwAEhG93pb1GcI8HLCQAvAD5ZRAyGwVoKAVjvAmVCO5UEOKPsWz2JwFh6eWc\
                WDsp4kEv/8T2ejXDyBWXOl4OsDFPqnK1h8gYHqHPmSfr6L/hM60Qu7d8pWxVynuRWt1WppQ26v/7EsRMgASgZW2lJKVgigwrABfEWEkJEP9f1vLPHjM2e\
                Q/RmYUbX/9QQkpFiv99C/kQxAKgnQAPKcoZEV++kLDOzqqngVBEIAXCUlne/SPbesKsmRTKrQ5jKAQNwFkmLEwlAe4t/rzvaP/7EMRSgASILWOAPYBAmY\
                trASeVkDi2kA2vBf7u/V92cbwiKKxYi8g2HHkItFU64G5r4h/pEMBvxP6EP/7nDdBb/4rv9VUZWqVG2yAAAWY4SFzWmjAx8z8YP7AMd84qL6EO6fqQfDA\
                S//sSxFaARFBbWgBgQcCKCGx0B6Qg9Y4lHyD/cB4AxLgqmC8mOkWyWekk2ygaemgq00dkJ/9Vil/7P/9AwgpwiBSF+wAB88BgS+6OD7H9HLdE2QhPEMcW\
                u4aDP1iIGyjlf//6BUGBAFAk//sQxF4ARFxDd4AwQbCJDK5wBJw+iABFI6ThmF+gECJYl/6Ds5AbWZ10MPlfq1AX/sb/dRA2HC3kggcfiSPIaOKMD2w0a\
                kDxkhaNfKOv/zGPF33f/6/+/iEFDYtLfwTJbDo9uohuI7H/+xLEZIAEZGmDoBihMJ0NLXQHnDBJEZj6G2AsdGAqPhwz9Mpr4kKqC5xlFFIsDmIABhww1l\
                47JnJxofc/0Pt07BdA38OBaUIvb/kCCt3//0CigWBPmMA08CjI5ZPah7is1qu3ObXM8iv/+xDEaQAEqEFzgqTGsJGIbXQEoCQ4UO4x/H+nOGafKYf92aU\
                fuoWdShEOV+zl+IAk6vb3/U3Vl6+EsJdbdRT6mf/5ANaBf/f2YAq21LOAXwn4s4HQIp7Nd/WBUJeB9mjaAg9aG/9yAP/7EsRtgESoyXODgFwwkQxuMASU\
                P4GmHo+tqfdFutiuvRpkFfMMPjBwPRooIuNK9Lk7i+W2LQiGBhShkeEr6fAN7/yf/n//br/b34JcRc3J3BwOsAUMnMxCrjtK1VBECaje0l/5mO97/f/7E\
                MRygAS0YWWBMEPAp4vr8AeUOP//ydP8QV5jWIT5IxUFGDh0Nk0gUYApNXiURHR0MGpkM6Ew7g9J9u/+UL7uv/75+lRn2V2KKVuQKAsAC6txUfF1QTHs8k\
                fxU2GL8nunPUDROpzZ//sSxHQDxKRZVgDgQcCoi2rBJ5So7/dyjbGurRhRNRMFGAeyIQ2N1tAkLjsctUjYbDBZyYmHtyQIfvDBL3Wf91gmGH4AAGoxIQH\
                zEZ8igc88K9a2xVuOcmgDcFBUmz4g9XuEn8l681fp//sQxHYABRjHYSM8Q0iiGPB0BJQuFVi2UlCATAGpnAuLjKxcFIDA/Jg9/mIgAcLaq3+XIOZ8Fw//\
                /1UQh1PByZhhjJbHCSAIVEj1Y2dSwcHp0l8yzYLDHQOfZyzf9fGmr7fvo++tHE7/+xLEdoAE1FeF4CThcJiGL3QXpA5mQbqgDAGtaKTe1VqZDVVyq3OeF\
                Rfqivqa+jf/NJ6ej//0jBMaAW1Uc9AGA3JouAsHBvzXLwob90B6KZI2g/09Ik+kLez//hAzwQvgQDnwcIx99Rz/+xDEegAEnDtngDDBwKCIK6UXmKjFq1\
                2ZrtGyGTlwELVEVkeu33IQEBPLih7//oCDYzYzRRGAGALjqD1l6EnD12XcimWzRdvOXUj//OCAqP////nFIzwMCNxMknRfSko21t57gHWuJP/7EsR9AAU\
                oQ3ugJWEwngzv/AYcNrgKufEfka3/1PEd071J7Et6m2pH/5UEMGgL6BsM4LUUzQ+FpNDa5STnAyl5Kglpsk6Wv5ibPt///r4PvQAEDAD6uUJKe890zCh/\
                KdWblsOQG7PIyf/7EMR+gESEaW2gMOGgl40tdHQI9HaQtUTfdThIwYB3pr3T3J/+6TQCz81oArJUA6bbMEOyzqSvhwAiaPGZV3Yg3t/CjFQWVq/zN+M9F\
                vROrREaCSdhlDbjQAGoRBnCMPbVSMwGne4g//sSxIMABNBdZSAwQcCUCrA8Bgg+Hgse6gsY+u2A1Ycu6fW+RAsQFRRJgKppYWUH45waVkby6ipwDQOuU/\
                8zq41fV/R/7+HKADFotoFTqAEkQPfRqL3IsUP+QQdRJUMoed896Sv7eSpr//sQxIcARSBTVQBhQYCXGSvw0A+MlqG30xBBIm+KgBToGxpYIcmkl2Najss\
                CSKBaLXFrDXXf9N8km/LV54IHu1vqfbydAwggwwgCAQEAAAAAgwWXiMkj5RL3hhXgIUT+YMKL/hRjBgL/+xLEiQAFUFFRDDyowKyPquQXlDj4VcR/WAkt\
                /WMVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xDEiAAEmClzo\
                7EGcIsJ6ZUHiKBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVf/7EsSNgAScLVOgLMGArwonQrCAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMSPAAWIZTdY0QAAAAA0g4AABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\
                VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"),
                siren: au("SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU5LjI3LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAA\
                AAAAASW5mbwAAAA8AAAALAAAFMwA3Nzc3Nzc3NzdLS0tLS0tLS0tfX19fX19fX19zc3Nzc3Nzc3OHh4eHh4eHh4ebm5ubm5ubm5uvr6+vr6+vr6/Dw8PD\
                w8PDw8PX19fX19fX19fr6+vr6+vr6+v///////////8AAAAATGF2YzU5LjM3AAAAAAAAAAAAAAAAJALAAAAAAAAABTPZCv7vAAAAAAD/+xDEAAAEQC0sV\
                JGAAKuPKgMyoACBAAgQBQUOEYBwNm1xWKwTDYrRtzREEBgu/Lh+CDv/KO4f1N/W3BDkTYUmDpwrAUrZfTcv8pXFgngfIIEJD0JNCXOG/zcwrzyvwQasBB\
                ewrsVXUv/7EsQDAAVgXW28xQAwmIuscBecVkABM7VKFJ0BY7GZk82prNvrTQ4nPvc9f7IPhXCaQ7ZWS89RKZASEFiQ6ooGV5BoxnuBzCdRu/91FkmVDzz\
                7W/6j4zP/k5z9ez+QDFUPF8AjICpWpv/7EMQEAAV4kU8gZaKApYzsNBecZJlaptdDUQjRbL+vnS6dFYpf/XorLogp9qtD/5nUsw+d3X/YaG5Aw8OEKQAH\
                WYXbJVGKRdkj0/XpQRhucOupD/8eGwnCc6S+twLxP8lGKgIQJAwT//sSxAKABOC5X2gAujCwGi40BIhmHnSssvRWQesWpdT/0ENZTNG//51MpnNbrUSR1\
                T/37guzlwNgbhkK22wAuFMEBcER3W5YBfnOpyIAlb/6nAzwFJf/yZTGrRv0F9pK//g0DQszhAAl//sQxAMABSiBTyBpowCoD2t0DBxglJJIiI4rtxe/b3\
                db9ax3kkHQULW/1mBcYrIX/T6adMlf8toAjA2wfnhYAGO70SBzZ2exrY5G/M4UEYYff/wHkTTyLfqx2NSTCPW9X+SqKAzAMID/+xLEAoAFQHtPIGjhAKY\
                WbfQEnC43q9PTgNHnTJRSXXjyKeh5RjgBAWjDP/44QPEn/5kb48/3fy+SFgC4awVroAHQQILB8et2KxZ/QxRalZ3/HCf/yY0UIwXP/+pwt/5hnUIKudoK\
                rYD/+xDEAoAFMJFIAGmhAKgJq/0GCOTwJkr3fZTIkX+tRsAiwqpRV/rWiIwSxeNkv/JB3Ud/8z5l8hkAQQNKkgZExUADUmmTZfB8EDhGNyY/Rt9Ze7a8T\
                29GkKIM789bl5XZ4M66FYatVv/7EsQCAETceWunoEnwlYrttMSI5qiYAAH8d9Hika2wz0Y9TVTgZGRbJfHViGvfbNo7wH/+gRIu6A5Wo041PEsELjwFMR\
                +1jU6/mID6rurM/Djsj/zihgZ5KObkJeoYKbGVyNMAAOHeDf/7EMQFgESAj3GgMEHwhInpQaQJ0Ay/7jMD07OMJOr1upw5E34c5wY3/q/b/4rmtvs9YTP\
                Zw23Ll2tlrW1nThplffuEJyqnygLzvDdtS/bVmF+s0jkDAACsvYUCz5ePnWuoHYjiTQEd//sSxAwARHhPdaCwQbCQi6kBp4iwuEGcM/1eQCf4d/5zUrep\
                HwVEH0CoK8DF379zIyZTjb016UXob31eDEJ/BDNTk6PWk8FJPGWZ0JIkYRSies9vyw5+rYBV+SA0Z9JOar1X/N3iIEPD//sQxBIDxDBLQgxowwCLhePBh\
                4zREAbxgSOoLdjQEDhCUWTUnSRVjkAz4ahhxWYqim/+aKrVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU="),
                vul: au("SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU5LjI3LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAA\
                AAASW5mbwAAAA8AAAAGAAADKQBaWlpaWlpaWlpaWlpaWlpae3t7e3t7e3t7e3t7e3t7e3ucnJycnJycnJycnJycnJycvb29vb29vb29vb29vb29vb3e3t\
                7e3t7e3t7e3t7e3t7e3v////////////////////8AAAAATGF2YzU5LjM3AAAAAAAAAAAAAAAAJATAAAAAAAAAAynzsb2FAAAAAAD/+xDEAAAEoCk2NJE\
                AAKWObEMeUAEIKIACAAAw4jFbdzmjRo57AOBg+8QAmH+H1Ag4oc4IQfD/B94fPgvCmIHsMKj/LbGh73JtK6UXCZAtfCG7T5AhVxNmJtG1WLZ/fvjUvHrq\
                gE1Oev/7EsQCAETkQWuclIAgqY/sYPMI8WMAAgEiAwHMJEAoFZcnLz72c9nZk5tv/xFmM2imJTPIvqT0QKE1OyqalUN0yD9fqngpAKuDyk1AEoPl73FD0\
                QP0M/g3Uv6Su3QOd+dgapRvMhEAGv/7EMQDAEVQWWMnpOcAnA1sFPMJWNqqwKtlFrwbRIVnskxc42I1Nq5+kw8CAtRX21cqbvtUE0t4OK4UistoF3bU1x\
                0mONzBJsybE531nTyBw5BCv61Kb9Q4tIieX4u4+TrXxCaoiFgA//sSxAOARVyVbaSEsGCnDewUwx2gAW0dOKhhG6ZsMHVpmEbb3q507ojh3fW1ll96hi1\
                ek6N02RYtwBExQKm4aplxkjEkJq2RENjNPfd2lyYDOqj8AgMDjMv1WliJmMAhHWt1q7hzJ4Zb//sQxAMABRxPe/STACCckOwDHnABcqAANJmAkwTnl2DE\
                2CGeF0ExZl1rb3/dsbK5YDQO/W7q45MFm3/htLr23dgf9E9qWhS6mxw04y3IgiTNKhE7d82era/cXs6R0Z3LLly76rTlcu//+xLEBIPFVGMiHMQAAAAAN\
                IAAAARla6mBICQig8ACBccoqv///K1DNIcg1OkVUs8N8RSx4qCyTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\
                o=")
            }

            // format body
            const body = document.body;
            body.style.margin = 0;
            body.style.overflow = 'hidden';

            //  canvas
            // create layers
            // Layer 1: Background Layer
            // Layer 2: Interaction Layer
            // Layer 3: Dynamic Layer
            // Layer 4: Text Layer
            const   r = resolution;
            const   columns = fl(width/r);
            const   rows = fl(height/r);
            const   displayPadding = 2*r;
            var layers = {};
            for (i of [1,2,3,4]) {
                const el = document.createElement('canvas');
                const obj = {
                    canvas: el,
                    ctx: el.getContext('2d'),
                }
                await sl(.1)
                obj.ctx.canvas.width = width;
                obj.ctx.canvas.height = height+displayPadding;
                if (i == 1) {
                    obj.ctx.fillStyle = retroBg;
                    obj.ctx.fillRect(0, 0, width, height+displayPadding);
                } else {
                    el.style.position = 'absolute';
                    el.style.top = '0';
                    el.style.left = '0';
                }
                el.style.width = columns * r;
                // leave padding below for display
                el.style.height = (rows+displayPadding/r) * r;
                el.style.zIndex = `${i}`;
                body.prepend(el);
                layers[i] = obj;
            }
            
            /* PacMan data */
            var pac = {
                p: {x:r,y:r},
                v: pacVelocity,               // velocity in px/s
                d: 'r',
                tol: .45 * r,       // tolerance spatial object extension
                mouth: [.2,.5,.8,.9,.8,.5,.2,0],
                phase: {'r': 0, 'u': 1.5*Math.PI , 'l': Math.PI, 'd': Math.PI/2},
                points: 0,
                steps: 1,
                show: 1
            }

            /* Ghost data */
            // https://en.wikipedia.org/wiki/Ghosts_(Pac-Man)
            var ghost = {
                // main ghost object
                back: {'l':'r','r':'l','u':'d','d':'u'},
                spawn: {x: fl(columns/2)*r, y: fl(rows/2+1)*r},
                v: ghostVelocity,
                cage: null,
                chase: 0,
                door: null,
                list: [],
                r: .01,
                vul: 0
            };

            /* Game data */
            var game = {
                lives: 3,
                up: 0,
                isOn: false,
                period: 15,
                coins: 0,
                coinPhase: 0,
                coinColor: ['#d6c78b', '#f2ed5a', '#cbcfc6', '#fcffcc']
            }

            // coin code
            function loadCoins (_grid, bigOnly=false) {
                for (i = 0; i < _grid.length; i++) {
                    for (j = 0; j < _grid[0].length; j++) {
                        if (_grid[i][j].c != 2 && !_grid[i][j].rigid && !isInCage(j*r,i*r)) {
                            if (u() < bigCoinRate) {
                                if (_grid[i][j].c != 1) {
                                    // if the space where a random big coin is layed down
                                    // is NOT used by a normal coin raise the coins number
                                    game.coins++;

                                }
                                _grid[i][j].c = 2;
                            } else if (!bigOnly) {
                                _grid[i][j].c = 1;
                            }
                            game.coins++
                        }
                    }
                }
                
            }
            async function eatCoin (x,y,_grid) {
                c = getCell(x+r/2,y+r/2,_grid);
                if (c.c) {
                    if (c.c > 1) {vulnerableTimeout(3+u()*7)}
                    c.c = 0;
                    game.coins--;
                    if (c.coin == 1) {
                        pac.points+=10;
                    } else {
                        pac.points+=20;
                    }
                    
                    for (i of [1,1]){
                        await sound.eat.play();
                    }
                    
                }
            }
            async function renderCoins (_grid, ctx) {
                var rad;
                const omega = 2*Math.PI*coinRotationRate;
                const dt = 1/maxFrameRate;
                const gcl = game.coinColor.length;
                while (1) {
                    await sl(1e3*dt)
                    ctx.clearRect(0, 0, width, height);
                    ctx.restore();
                    // ctx.save();
                    if(!game.isOn){continue}
                    for (i = 0; i < _grid.length; i++) {
                        for (j = 0; j < _grid[0].length; j++) {
                            const c = _grid[i][j];
                            if (c.c) {

                                if (c.c == 1) {
                                    rad = r/3/4;
                                } else {
                                    rad = r/3/2;
                                }
                                
                                sine = .5*(Math.sin(game.coinPhase)+1);
                                
                                ctx.beginPath();
                                ctx.ellipse(c.x+fl(r/2), c.y+fl(r/2), rad, rad, 0, 0, 2 * Math.PI);
                                ctx.fillStyle = game.coinColor[fl(sine*gcl)];
                                ctx.closePath();
                                ctx.fill();
                                
                            }
                        }
                    }
                    game.coinPhase = (game.coinPhase + omega * dt) % (2*Math.PI)
                } 
                
            }

            // game options
            function setText (text, ctx, x, y, fillColor, strokeColor, fontSize=fl(r/3), center=true) {
                
                // center text
                if (center) {x -= fl(ctx.measureText(text).width/2)}
                
                //x -= Math.max(0, (text.length) * fontSize / 2-40);
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                fontData = `${fontSize}px Arial Black`;
                ctx.font = fontData;
                ctx.fillText(text, x, y); 
                ctx.strokeText(text, x, y);

            }
            async function newGame (_grid) {

                const   activeCtx = layers[3].ctx,
                        textCtx = layers[4].ctx;

                // fill grid with coins 
                loadCoins(_grid);

                // define text location
                const gc = ghost.cage;
                const [xt, yt] = [fl(width/2+r/2), (gc[1][1]+.6)*r];
                for (let i = 0; i < 12; i++) {
                    const c = ['#fff','#000'][i%2];
                    setText ('READY!', textCtx, xt, yt, c, c)
                    await sl(100);
                    cl(textCtx);
                }
                

                // switch on the game and give pacman 5 seconds advantage
                cl(textCtx);
                game.isOn = 1;

                // wait until ghosts left the cage, and close it
                await sl(5e3);
                await releaseGhosts(_grid);

                soundLoop();

                // iteratively switch between chase and random, raise the velocity
                const catchLimit = (.75*r)**2
                while (game.lives > 0) {
                    
                    await sl(30);
                    
                    for (g of ghost.list) {
                        
                        // check if pacman was caught
                        distance = distTo(g.p.x, g.p.y, pac.p.x, pac.p.y);
                        if (distance < catchLimit) {

                            if (ghost.vul) { 
                                g.p = {x:ghost.spawn.x+(u()-.5)*r, y:ghost.spawn.y+(u()-.5)*r};
                                game.isOn = 0;
                                await sl(1e3);
                                game.isOn = 1;
                                pac.points += 200;
                                await sl(5e3);
                                await releaseGhosts(_grid);
                                break
                            }


                            sound.die.play()
                            
                            game.isOn = 0;
                            await sl(3e3);
                            
                            pac.p = {x:r,y:r};
                            pac.d = 'r';
                            game.lives--;
                            

                            if (game.lives == 0) {
                                pac.show = 0;
                                game.isOn = 1;
                                pac.p = {x:0,y:0};
                                ghostVelocity = .1;
                                break
                            }

                            // generate a few new bigcoins coins 
                            //loadCoins(_grid, 1);

                            for (g of ghost.list) {
                                g.p = {x:ghost.spawn.x+(u()-.5)*r, y:ghost.spawn.y+(u()-.5)*r}
                            }

                            for (let i = 0; i < 12; i++) {
                                await renderDynamicLayer(layers[3].ctx);
                                pac.show = !pac.show;
                                await sl(100)
                            }
                            
                            
                            game.isOn = 1;
                            await releaseGhosts(_grid);

                            break
                        }
                    }
                }

                setText ('GAME OVER', textCtx, xt, yt, '#fff', '#fff')


            }
             
            // grid code
            function getCell (x, y, grid) {
                return grid[fl(y/r)][fl(x/r)]
            }
            function fillCell (x, y, color, grid, ctx) {
                const c = getCell(x, y, grid);
                ctx.fillStyle = color;
                ctx.fillRect(c.x, c.y, r, r);
            }
            async function grid (columns, rows, resolution, yOff=0) {
                let     mat = [];
                const   c = resolution;
                for (let i=0; i<rows; i++) {
                    row = [];
                    for (let j=0; j<columns; j++) {
                        row.push({
                            x:j*c,
                            y:(i+yOff)*c,
                            rigid:0,
                            c:0,
                        })
                    } 
                    mat.push(row)
                } 
                return mat;
            }
            function incrementCoord (x, y, d, i) {
                [xn,yn]=[x,y]
                if (d == '') {
                    return [x,y]
                } else if (d == 'r') {
                    xn += i
                } else if (d == 'l') {
                    xn -= i
                } else if (d == 'u') {
                    yn -= i
                } else if (d == 'd') {
                    yn += i
                } return [xn,yn]
            }
            function isInCage (x, y) {
                const g = ghost;
                if (x<g.cage[0][0]*r||x>g.cage[0][1]*r||y<g.cage[1][0]*r||y>g.cage[1][1]*r) {
                    return false
                } 
                return true
            }
            function isRigid (x, y, grid) {
                return getCell(x, y, grid).rigid
            }
            async function isSpaceForWallBlock (x, y, grid) {            
                for (i of [-1,0,1]) {
                    for (j of [-1,0,1]) {
                        const [xn,yn] = [x+j*r,y+i*r];
                        if (isRigid(xn, yn, grid)) {
                            return false
                        }
                    }
                }
                return true
            }
            async function isSpaceToContinueWall (x, y, d, grid) {
                const [xn,yn] = incrementCoord(x,y,d,r);
                for (let i of [-1,0,1]) {
                    for (let j of [-1,0,1]) {
                        const [x_t,y_t] = [xn+j*r, yn+i*r];
                        if (!(y_t==y||x_t==x) && isRigid(x_t, y_t, grid)) {
                            return false
                        }
                    }
                }
                return true
            }
            async function setWallBlock (ctx, col, row, res, grid, color, rigid=1) {
                fillCell(col*res, row*res, color, grid, ctx);
                grid[row][col].rigid = rigid;
            }
            
            // maze code (with grid code dependency)
            async function canMoveInDir (x, y, d, grid, inc=1) {
                bias = 2;
                b1 = r-bias;
                b2 = bias;
                if (d == 'r') {
                    p1 = incrementCoord(x+r,y+b2,d,inc);
                    p2 = incrementCoord(x+r,y+b1,d,inc);
                } else if (d == 'd') {
                    p1 = incrementCoord(x+b2,y+r,d,inc);
                    p2 = incrementCoord(x+b1,y+r,d,inc);
                } else if (d == 'l') {
                    p1 = incrementCoord(x,y+b2,d,inc);
                    p2 = incrementCoord(x,y+b1,d,inc);
                } else if (d == 'u') {
                    p1 = incrementCoord(x+b2,y,d,inc);
                    p2 = incrementCoord(x+b1,y,d,inc);
                }
                return !isRigid(p1[0],p1[1],grid) && !isRigid(p2[0],p2[1],grid)
            }
            async function maze (grid, ctx, color, snakes=100, length=100, gaprate=0, yOff=0) {
                
                const   g = grid;
                const   res = g[0][1].x - g[0][0].x,
                        col = g[0].length,
                        row = g.length;

                ctx.fillStyle = color;
                
                // create outter frame
                for (let i=0; i<rows; i++) {
                    await setWallBlock(ctx, 0, i, res, g, color);
                    await setWallBlock(ctx, col-1, i, res, g, color)
                }
                for (let i=0; i<col; i++) {
                    await setWallBlock(ctx, i, 0, res, g, color);
                    await setWallBlock(ctx, i, row-1, res, g, color)
                }

                // place the cage
                dim = [];
                for (ind of [0,1]) {
                    d = [col, row][ind]
                    if (d % 2 == 0){
                        dim[ind] = 4
                    } else {
                        dim[ind] = 3
                    }
                }
                if (col>row && dim[1]>4){dim[1]--}
                
                start = [fl((col-dim[0])/2), fl((row-dim[1])/2)];
                await setWallBlock(ctx, start[0], start[1], res, g, color)
                for (let x = 0; x < dim[0]+1; x++) {
                    await setWallBlock(ctx, start[0]+x, start[1], res, g, color);
                    await setWallBlock(ctx, start[0]+x, start[1]+dim[1], res, g, color);
                    
                } 
                for (let y = yOff; y < dim[1]; y++) {
                    await setWallBlock(ctx, start[0], start[1]+y, res, g, color);
                    await setWallBlock(ctx, start[0]+dim[0], start[1]+y, res, g, color);
                }
                ghost.cage = [[start[0],start[0]+dim[0]],[start[1],start[1]+dim[1]]];

                // install cage door
                ghost.door = {col: fl(start[0]+dim[0]/2), row: fl(start[1])} 
                await setWallBlock(ctx, ghost.door.col, ghost.door.row, res, g, retroBg);
                ctx.fillStyle = '#fff';
                ctx.fillRect(ghost.door.col*res, ghost.door.row*res+.4*res, res, .2*res);

                // fill internal space with snake method
                let p = {r:2,c:2},
                    br = 0;
                for (let i = 0; i < snakes; i++) {

                    // find new position, if search takes to long it ran out of space, then return
                    const lim = row*col*100;
                    for (let z = 0; z < lim; z++) {
                        // sample new point
                        const [c,r] = [fl(u()*(col-4))+2, fl(u()*(row-4))+2];
                        const [x,y] = [c*res, r*res];
                        if (!isInCage(x,y) && await isSpaceForWallBlock(x,y,g)) {
                            p.c = c;
                            p.r = r;
                            break
                        }
                        if (z == lim-1) {
                            br = 1;
                            break
                        }
                    } 
                    if (br) {break}
                    
                    // fill starting point
                    await setWallBlock(ctx, p.c, p.r, res, g, color)
                    
                    v = '', v_old = '', p_old = [];
                    count = 0;
                    for (let i=0; i<length; i++) {

                        // check directions
                        let d = [];
                        for (let direction of ['l', 'r', 'u', 'd']) {
                            if (await isSpaceToContinueWall(p.c*r, p.r*r, direction, g)) {
                                d.push(direction)
                            }
                        }
                        
                        // throw a die with geom. decreasing probability to keep the same direction
                        if (!(d.includes(v) && u() < 1/(1+count))) {
                            v = d[fl(u()*d.length)]
                            count = 0
                        }

                        // terminate snake if no direction is left
                        if (!d.length) {break}

                        // adjust position
                        [x_override, y_override] = incrementCoord(p.c*r, p.r*r, v, 1)
                        p.c = fl(x_override/r);
                        p.r = fl(y_override/r);

                        // increment the length
                        count++;

                        // set wall at former coord if direction hasn't chagned to leave sometimes a gap
                        if (v == v_old && u() < gaprate) {
                            await setWallBlock(ctx, p_old[0], p_old[1], res, g, retroBg, 0)
                        }
                        await setWallBlock(ctx, p.c, p.r, res, g, color);

                        v_old = v;
                        p_old = [p.c, p.r];
                    
                    }
                }
            
                // fill free space
                count = 0;
                for (let repeat = 0; repeat < 10; repeat++) {
                    for (let i = 3; i < row; i++) {
                        for (let j = 3; j < col; j++) {
                            const cell = g[i][j];
                            if (isInCage(cell.x, cell.y)) {continue}
                            if (!cell.rigid) {
                                for (let [a,b] of [
                                    [1,0],
                                    [1,1],
                                    [0,1],
                                    [-1,1],
                                    [-1,0],
                                    [-1,-1],
                                    [0,-1],
                                    [1,-1]
                                ]) {
                                    if (g[i+a][j+b].rigid) {
                                        count++
                                    }
                                    if (count > 1) {
                                        break
                                    }
                                }
                                if (count == 1) {
                                    await setWallBlock(ctx, j, i, res, g, color);
                                    
                                }
                                count = 0;
                            }
                        }
                    }
                }
                
                
            }
            function openDoor (grid,v=0) {
                grid[ghost.door.row][ghost.door.col].rigid = v
            }
            async function releaseGhosts (_grid) {
                openDoor(_grid);
                allLeft=0;
                while (!allLeft) {
                    allLeft=1;
                    for (g of ghost.list) {
                        if (isInCage(g.p.x,g.p.y)) {
                            allLeft=0
                        }
                    }
                    await sl(10);
                }
                openDoor(_grid, 1);
            }

            // pac-man code
            async function drawPacMan (ctx, x=pac.p.x,y=pac.p.y, fixedDir=null) {
                const rad = fl(r/2);
                const c = [x+rad, y+rad];
                if (fixedDir) {
                    mouthIndex = 0;
                } else {
                    mouthIndex = fl(2*pac.steps*pac.mouth.length/r);
                }

                const mouth_state = pac.mouth[mouthIndex % pac.mouth.length];
                
                ctx.save()
                ctx.beginPath();
                ctx.translate(c[0], c[1])
                if (fixedDir) {
                    ctx.rotate(pac.phase[fixedDir])
                } else {
                    ctx.rotate(pac.phase[pac.d])
                }
                
                ctx.moveTo(0, 0)
                ctx.arc(0, 0, rad, mouth_state, 2*Math.PI-mouth_state);
                ctx.fillStyle = ctx.strokeStyle = '#d9e312';
                ctx.lineTo(0, 0);
                ctx.lineTo(rad*Math.cos(mouth_state),rad*Math.sin(mouth_state));
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            async function movePacMan (_grid) {
                [pac.p.x, pac.p.y]=incrementCoord(pac.p.x, pac.p.y, pac.d, increments);
                pac.steps++;
                eatCoin(pac.p.x, pac.p.y, _grid)
            }
            async function movePacManContinuously (grid) {
                var dir = pac.d;
                while (dir == pac.d) {
                    await sl(increments/pac.v)
                    if (!game.isOn) {continue}
                    if (pac.reserve != '' && await canMoveInDir(pac.p.x, pac.p.y, pac.reserve, grid, increments)) {
                        pac.d = pac.reserve;
                        dir = pac.d;
                        pac.reserve = '';
                    } else if (!(await canMoveInDir(pac.p.x, pac.p.y, pac.d, grid, increments))) {
                        return
                    }
                    movePacMan (grid)
                    
                }
            }
            function bindKeyBoard (pacManObj, grid) {
                document.addEventListener('keydown', async(event) => {
                    if (game.isOn) {
                        var k = event.key, d;
                        if ( k == 'w' || k == 'ArrowUp' ) {d = 'u'} 
                        else if ( k == 'a' || k == 'ArrowLeft' ) {d = 'l'} 
                        else if ( k == 's' || k == 'ArrowDown' ) {d = 'd'} 
                        else if ( k == 'd' || k == 'ArrowRight' ) {d = 'r'}
                        if (d == pacManObj.d) {
                            //
                        } else if (await canMoveInDir(pacManObj.p.x, pacManObj.p.y, d, grid, increments) && pacManObj.d != d) {
                            pacManObj.d = d;
                            movePacManContinuously(grid);
                        } else if (pacManObj.d != d) {
                            pacManObj.reserve = d;
                        }
                    }
                    
                }, false);
                document.addEventListener('keyup', (event) => {
                    pacManObj.reserve = '';
                }, false);
            }
            
            // ghost code
            function initGhost (x, y, color) {
                ghost.list.push({
                    p: {
                        x: x,
                        y: y
                    },
                    c: color,
                    d: 'r',          // direction
                    s: 0,           // steps
                    r: 1          // randomness
                })
            }
            function distTo (x, y, x_t, y_t) {
                return ((x_t-x)**2+(y_t-y)**2)
            }
            async function drawGhost (_ghost, ctx) {
                const   rad = fl(resolution/2);
                const c = [_ghost.p.x+rad, _ghost.p.y+rad];
                ctx.beginPath();
                ctx.arc(c[0], c[1], rad, -Math.PI, 0);

                // draw all blue if ghosts are vulnerable
                if (ghost.vul) {
                    ctx.fillStyle = ctx.strokeStyle = '#0c1794';
                } else {
                    ctx.fillStyle = ctx.strokeStyle = _ghost.c;
                }
                
                ctx.fillRect(_ghost.p.x, _ghost.p.y+rad, resolution, fl(rad/2));
                for ([dx,dy] of [[2,2],[1.75,1.75],[1.5,2],[1.25,1.75],[1,2],[.75,1.75],[.5,2],[.25,1.75],[0,2],[0,1.75]]) {
                    ctx.lineTo(_ghost.p.x+dx*rad, _ghost.p.y+dy*rad);
                }
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                for (s of [-1,1]) {
                    ctx.arc(c[0]+s*fl(rad/2.3), c[1]-fl(rad/3.5), fl(rad/3), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();    
                }
                ctx.closePath();
                
                // eyes
                ctx.fillStyle = retroBg;
                ctx.beginPath();
                if (_ghost.d == 'u') {
                    bias = [0,-.2]
                } else if (_ghost.d == 'd') {
                    bias = [0,.2]
                } else if (_ghost.d == 'l') {
                    bias = [-.2,0]
                } else if (_ghost.d == 'r') {
                    bias = [.2,0]
                } else {
                    bias = [0,0]
                }
                ctx.arc(c[0]+fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.arc(c[0]-fl(rad/2.3)+bias[0]*rad, c[1]-fl(rad/3.5)+bias[1]*rad, fl(rad/4), 0, 2*Math.PI);
                ctx.fill();
                ctx.closePath();
            }
            async function sampleNewDir (pd) {
                return pd[fl(u()*pd.length)]
            }
            async function moveGhost (_ghost, grid) {
                
                var direction,t;
                const [x, y, g, G, I, backDir] = [_ghost.p.x, _ghost.p.y, _ghost, ghost, increments, ghost.back[_ghost.d]];
                
                // determine possible directions, 
                var pd = [], nd = []; 
                for (d of ['l','r','u','d']) {
                    if (await canMoveInDir(x, y, d, grid, I)) {
                        pd.push(d)
                        if (![g.d,backDir].includes(d)) {
                            nd.push(d)
                        }
                    }
                }

                // if there is only one option choose it
                if (pd.length < 2) {
                    direction = pd[0]
                }

                // run algorithm code if direction is not yet determined
                if (!direction) {

                    // select moving parameters depending on case
                    t = [pac.p.x, pac.p.y]
                    if (isInCage(x,y)) {
                        // cage movement code
                        t = [G.door[0], G.door[1]-1]
                    } else if (G.chase) {
                        // code for chase
                        [G.v, G.r] = [1.5*ghostVelocity, 0.02]
                    } else {
                        // random movement
                        [G.v, G.r] = [0.8*ghostVelocity, 0.05]
                    }

                    // perform algorithm
                    if (pd.includes(g.d)) {
                        direction = g.d;
                        if (nd.length > 0 && u() < G.r) {
                            direction = await sampleNewDir(nd);
                            g.s = 0
                        }
                    } else {
                        // try to decrease distance when in chase mode
                        // otherwise try to increase it when vulnerable
                        let cond, min;
                        if (G.vul) {min = 0}
                        else {min = 1e6}
                        for (d of pd) {
                            [xn, yn] = incrementCoord(x,y,d,I);
                            dist = distTo(xn, yn, t[0], t[1]);
                            if (G.vul) {
                                cond = dist > min
                            } else {
                                cond = dist < min
                            }
                            if (cond) {
                                min = dist;
                                direction = d
                            }
                        }
                        g.s = 0
                    }

                }

                // update direction if determined
                if (direction) { g.d = direction }

                // apply increment in chosen direction
                [g.p.x, g.p.y] = incrementCoord(g.p.x, g.p.y, g.d, I);
                g.s++

            }
            async function moveGhostContinously (_ghost, grid) {
                while (1) {
                    await sl(increments/ghost.v)
                    if (!game.isOn) {continue}
                    await moveGhost (_ghost, grid);
                }
            }
            async function vulnerableTimeout (t) {
                ghost.vul = 1;
                const v = ghostVelocity;
                ghostVelocity = 0.1;
                await sl(t*1e3);
                ghost.vul = 0;
                ghostVelocity = v;

            }
            async function soundLoop () {
                while (game.lives>0) {
                    
                    // design sound
                    await sl(5);
                    if (!game.isOn || sound.mute) {
                        continue
                    } else {
                        sound.siren.mozPreservesPitch = false;
                        sound.siren.playbackRate = 1 + 0.2*(3-game.lives);
                        
                        if (ghost.vul) {
                            await sound.vul.play();
                        } else {
                            await sound.siren.play();
                        }
                    }
                }
            }
            
            // render code
            async function renderDisplay (interCtx) {
                b = [[0, rows*r], [columns*r, (rows+2)*r]];
                while (1) {

                    await sl(1e3/maxFrameRate);

                    // display score in the lower center
                    interCtx.clearRect(b[0][0], b[0][1], b[1][0], 2*r);
                    setText(`SCORE ${pac.points}`, interCtx, fl(width/2), b[0][1]+fl(r), '#fff', '#fff', fl(r/2));

                    // display lives left
                    for (let i=0; i<game.lives; i++) {
                        const x_coord = (i*1.2+1)*r;
                        drawPacMan(interCtx, x_coord, b[0][1]+fl(.5*r), 'l')
                    } 
                }
            }
            async function renderDynamicLayer (dynCtx) {
                dynCtx.clearRect(0, 0, width, height);
                if (pac.show) {
                    await drawPacMan(dynCtx);
                }
                for (g of ghost.list) {
                    await drawGhost(g, dynCtx)
                }
            }
            async function renderEngine (dynCtx, interCtx) {
                
                // initialize asynchronous coin rendering 
                // on interactive layer
                renderCoins(_grid, interCtx);
                renderDisplay(interCtx);

                // start rendering content on dynamic layer
                while (1) {
                    try {
                        await renderDynamicLayer(dynCtx, interCtx)
                    } catch (error) {
                        console.error(error)
                    } finally {
                        await sl(1e3/maxFrameRate)
                    }
                }
            }

            /* -- instantiate -- */
            const staticCtx = layers[1].ctx;
            const interCtx = layers[2].ctx;
            const dynamicCtx = layers[3].ctx;

            // load all ghosts to cage
            for (c of ['red', 'cyan', 'orange', 'pink']) {
                initGhost(ghost.spawn.x+(u()-.5)*r, ghost.spawn.y, c)
            }

            // instantiate grid
            const _grid = await grid(columns, rows, r);

            // initialize maze on background layer
            await maze(_grid, staticCtx, wallColor, snakes=mazeWallNumber, length=mazeWallLength, gaprate=0.1);
            
            for (gs of ghost.list) {
                moveGhostContinously(gs,_grid)
            }

            // bind keys to pacman
            bindKeyBoard(pac, _grid);

            // ignite asynchronous render engine
            renderEngine(dynamicCtx, interCtx);
            
            // start new game
            newGame(_grid);
            
            
        })();
        

    </script>

</body>

</html>